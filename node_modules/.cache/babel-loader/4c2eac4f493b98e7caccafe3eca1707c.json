{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? t(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], t) : t((e.Leaflet = e.Leaflet || {}, e.Leaflet.markercluster = e.Leaflet.markercluster || {}));\n}(this, function (e) {\n  \"use strict\";\n\n  var t = L.MarkerClusterGroup = L.FeatureGroup.extend({\n    options: {\n      maxClusterRadius: 80,\n      iconCreateFunction: null,\n      clusterPane: L.Marker.prototype.options.pane,\n      spiderfyOnMaxZoom: !0,\n      showCoverageOnHover: !0,\n      zoomToBoundsOnClick: !0,\n      singleMarkerMode: !1,\n      disableClusteringAtZoom: null,\n      removeOutsideVisibleBounds: !0,\n      animate: !0,\n      animateAddingMarkers: !1,\n      spiderfyDistanceMultiplier: 1,\n      spiderLegPolylineOptions: {\n        weight: 1.5,\n        color: \"#222\",\n        opacity: .5\n      },\n      chunkedLoading: !1,\n      chunkInterval: 200,\n      chunkDelay: 50,\n      chunkProgress: null,\n      polygonOptions: {}\n    },\n    initialize: function (e) {\n      L.Util.setOptions(this, e), this.options.iconCreateFunction || (this.options.iconCreateFunction = this._defaultIconCreateFunction), this._featureGroup = L.featureGroup(), this._featureGroup.addEventParent(this), this._nonPointGroup = L.featureGroup(), this._nonPointGroup.addEventParent(this), this._inZoomAnimation = 0, this._needsClustering = [], this._needsRemoving = [], this._currentShownBounds = null, this._queue = [], this._childMarkerEventHandlers = {\n        dragstart: this._childMarkerDragStart,\n        move: this._childMarkerMoved,\n        dragend: this._childMarkerDragEnd\n      };\n      var t = L.DomUtil.TRANSITION && this.options.animate;\n      L.extend(this, t ? this._withAnimation : this._noAnimation), this._markerCluster = t ? L.MarkerCluster : L.MarkerClusterNonAnimated;\n    },\n    addLayer: function (e) {\n      if (e instanceof L.LayerGroup) return this.addLayers([e]);\n      if (!e.getLatLng) return this._nonPointGroup.addLayer(e), this.fire(\"layeradd\", {\n        layer: e\n      }), this;\n      if (!this._map) return this._needsClustering.push(e), this.fire(\"layeradd\", {\n        layer: e\n      }), this;\n      if (this.hasLayer(e)) return this;\n      this._unspiderfy && this._unspiderfy(), this._addLayer(e, this._maxZoom), this.fire(\"layeradd\", {\n        layer: e\n      }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons();\n      var t = e,\n          i = this._zoom;\n      if (e.__parent) for (; t.__parent._zoom >= i;) t = t.__parent;\n      return this._currentShownBounds.contains(t.getLatLng()) && (this.options.animateAddingMarkers ? this._animationAddLayer(e, t) : this._animationAddLayerNonAnimated(e, t)), this;\n    },\n    removeLayer: function (e) {\n      return e instanceof L.LayerGroup ? this.removeLayers([e]) : e.getLatLng ? this._map ? e.__parent ? (this._unspiderfy && (this._unspiderfy(), this._unspiderfyLayer(e)), this._removeLayer(e, !0), this.fire(\"layerremove\", {\n        layer: e\n      }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), e.off(this._childMarkerEventHandlers, this), this._featureGroup.hasLayer(e) && (this._featureGroup.removeLayer(e), e.clusterShow && e.clusterShow()), this) : this : (!this._arraySplice(this._needsClustering, e) && this.hasLayer(e) && this._needsRemoving.push({\n        layer: e,\n        latlng: e._latlng\n      }), this.fire(\"layerremove\", {\n        layer: e\n      }), this) : (this._nonPointGroup.removeLayer(e), this.fire(\"layerremove\", {\n        layer: e\n      }), this);\n    },\n    addLayers: function (e, t) {\n      if (!L.Util.isArray(e)) return this.addLayer(e);\n      var i,\n          n = this._featureGroup,\n          r = this._nonPointGroup,\n          s = this.options.chunkedLoading,\n          o = this.options.chunkInterval,\n          a = this.options.chunkProgress,\n          h = e.length,\n          l = 0,\n          u = !0;\n\n      if (this._map) {\n        var _ = new Date().getTime(),\n            d = L.bind(function () {\n          for (var c = new Date().getTime(); h > l; l++) {\n            if (s && 0 === l % 200) {\n              var p = new Date().getTime() - c;\n              if (p > o) break;\n            }\n\n            if (i = e[l], i instanceof L.LayerGroup) u && (e = e.slice(), u = !1), this._extractNonGroupLayers(i, e), h = e.length;else if (i.getLatLng) {\n              if (!this.hasLayer(i) && (this._addLayer(i, this._maxZoom), t || this.fire(\"layeradd\", {\n                layer: i\n              }), i.__parent && 2 === i.__parent.getChildCount())) {\n                var f = i.__parent.getAllChildMarkers(),\n                    m = f[0] === i ? f[1] : f[0];\n\n                n.removeLayer(m);\n              }\n            } else r.addLayer(i), t || this.fire(\"layeradd\", {\n              layer: i\n            });\n          }\n\n          a && a(l, h, new Date().getTime() - _), l === h ? (this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds)) : setTimeout(d, this.options.chunkDelay);\n        }, this);\n\n        d();\n      } else for (var c = this._needsClustering; h > l; l++) i = e[l], i instanceof L.LayerGroup ? (u && (e = e.slice(), u = !1), this._extractNonGroupLayers(i, e), h = e.length) : i.getLatLng ? this.hasLayer(i) || c.push(i) : r.addLayer(i);\n\n      return this;\n    },\n    removeLayers: function (e) {\n      var t,\n          i,\n          n = e.length,\n          r = this._featureGroup,\n          s = this._nonPointGroup,\n          o = !0;\n\n      if (!this._map) {\n        for (t = 0; n > t; t++) i = e[t], i instanceof L.LayerGroup ? (o && (e = e.slice(), o = !1), this._extractNonGroupLayers(i, e), n = e.length) : (this._arraySplice(this._needsClustering, i), s.removeLayer(i), this.hasLayer(i) && this._needsRemoving.push({\n          layer: i,\n          latlng: i._latlng\n        }), this.fire(\"layerremove\", {\n          layer: i\n        }));\n\n        return this;\n      }\n\n      if (this._unspiderfy) {\n        this._unspiderfy();\n\n        var a = e.slice(),\n            h = n;\n\n        for (t = 0; h > t; t++) i = a[t], i instanceof L.LayerGroup ? (this._extractNonGroupLayers(i, a), h = a.length) : this._unspiderfyLayer(i);\n      }\n\n      for (t = 0; n > t; t++) i = e[t], i instanceof L.LayerGroup ? (o && (e = e.slice(), o = !1), this._extractNonGroupLayers(i, e), n = e.length) : i.__parent ? (this._removeLayer(i, !0, !0), this.fire(\"layerremove\", {\n        layer: i\n      }), r.hasLayer(i) && (r.removeLayer(i), i.clusterShow && i.clusterShow())) : (s.removeLayer(i), this.fire(\"layerremove\", {\n        layer: i\n      }));\n\n      return this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds), this;\n    },\n    clearLayers: function () {\n      return this._map || (this._needsClustering = [], this._needsRemoving = [], delete this._gridClusters, delete this._gridUnclustered), this._noanimationUnspiderfy && this._noanimationUnspiderfy(), this._featureGroup.clearLayers(), this._nonPointGroup.clearLayers(), this.eachLayer(function (e) {\n        e.off(this._childMarkerEventHandlers, this), delete e.__parent;\n      }, this), this._map && this._generateInitialClusters(), this;\n    },\n    getBounds: function () {\n      var e = new L.LatLngBounds();\n      this._topClusterLevel && e.extend(this._topClusterLevel._bounds);\n\n      for (var t = this._needsClustering.length - 1; t >= 0; t--) e.extend(this._needsClustering[t].getLatLng());\n\n      return e.extend(this._nonPointGroup.getBounds()), e;\n    },\n    eachLayer: function (e, t) {\n      var i,\n          n,\n          r,\n          s = this._needsClustering.slice(),\n          o = this._needsRemoving;\n\n      for (this._topClusterLevel && this._topClusterLevel.getAllChildMarkers(s), n = s.length - 1; n >= 0; n--) {\n        for (i = !0, r = o.length - 1; r >= 0; r--) if (o[r].layer === s[n]) {\n          i = !1;\n          break;\n        }\n\n        i && e.call(t, s[n]);\n      }\n\n      this._nonPointGroup.eachLayer(e, t);\n    },\n    getLayers: function () {\n      var e = [];\n      return this.eachLayer(function (t) {\n        e.push(t);\n      }), e;\n    },\n    getLayer: function (e) {\n      var t = null;\n      return e = parseInt(e, 10), this.eachLayer(function (i) {\n        L.stamp(i) === e && (t = i);\n      }), t;\n    },\n    hasLayer: function (e) {\n      if (!e) return !1;\n      var t,\n          i = this._needsClustering;\n\n      for (t = i.length - 1; t >= 0; t--) if (i[t] === e) return !0;\n\n      for (i = this._needsRemoving, t = i.length - 1; t >= 0; t--) if (i[t].layer === e) return !1;\n\n      return !(!e.__parent || e.__parent._group !== this) || this._nonPointGroup.hasLayer(e);\n    },\n    zoomToShowLayer: function (e, t) {\n      \"function\" != typeof t && (t = function () {});\n\n      var i = function () {\n        !e._icon && !e.__parent._icon || this._inZoomAnimation || (this._map.off(\"moveend\", i, this), this.off(\"animationend\", i, this), e._icon ? t() : e.__parent._icon && (this.once(\"spiderfied\", t, this), e.__parent.spiderfy()));\n      };\n\n      e._icon && this._map.getBounds().contains(e.getLatLng()) ? t() : e.__parent._zoom < Math.round(this._map._zoom) ? (this._map.on(\"moveend\", i, this), this._map.panTo(e.getLatLng())) : (this._map.on(\"moveend\", i, this), this.on(\"animationend\", i, this), e.__parent.zoomToBounds());\n    },\n    onAdd: function (e) {\n      this._map = e;\n      var t, i, n;\n      if (!isFinite(this._map.getMaxZoom())) throw \"Map has no maxZoom specified\";\n\n      for (this._featureGroup.addTo(e), this._nonPointGroup.addTo(e), this._gridClusters || this._generateInitialClusters(), this._maxLat = e.options.crs.projection.MAX_LATITUDE, t = 0, i = this._needsRemoving.length; i > t; t++) n = this._needsRemoving[t], n.newlatlng = n.layer._latlng, n.layer._latlng = n.latlng;\n\n      for (t = 0, i = this._needsRemoving.length; i > t; t++) n = this._needsRemoving[t], this._removeLayer(n.layer, !0), n.layer._latlng = n.newlatlng;\n\n      this._needsRemoving = [], this._zoom = Math.round(this._map._zoom), this._currentShownBounds = this._getExpandedVisibleBounds(), this._map.on(\"zoomend\", this._zoomEnd, this), this._map.on(\"moveend\", this._moveEnd, this), this._spiderfierOnAdd && this._spiderfierOnAdd(), this._bindEvents(), i = this._needsClustering, this._needsClustering = [], this.addLayers(i, !0);\n    },\n    onRemove: function (e) {\n      e.off(\"zoomend\", this._zoomEnd, this), e.off(\"moveend\", this._moveEnd, this), this._unbindEvents(), this._map._mapPane.className = this._map._mapPane.className.replace(\" leaflet-cluster-anim\", \"\"), this._spiderfierOnRemove && this._spiderfierOnRemove(), delete this._maxLat, this._hideCoverage(), this._featureGroup.remove(), this._nonPointGroup.remove(), this._featureGroup.clearLayers(), this._map = null;\n    },\n    getVisibleParent: function (e) {\n      for (var t = e; t && !t._icon;) t = t.__parent;\n\n      return t || null;\n    },\n    _arraySplice: function (e, t) {\n      for (var i = e.length - 1; i >= 0; i--) if (e[i] === t) return e.splice(i, 1), !0;\n    },\n    _removeFromGridUnclustered: function (e, t) {\n      for (var i = this._map, n = this._gridUnclustered, r = Math.floor(this._map.getMinZoom()); t >= r && n[t].removeObject(e, i.project(e.getLatLng(), t)); t--);\n    },\n    _childMarkerDragStart: function (e) {\n      e.target.__dragStart = e.target._latlng;\n    },\n    _childMarkerMoved: function (e) {\n      if (!this._ignoreMove && !e.target.__dragStart) {\n        var t = e.target._popup && e.target._popup.isOpen();\n\n        this._moveChild(e.target, e.oldLatLng, e.latlng), t && e.target.openPopup();\n      }\n    },\n    _moveChild: function (e, t, i) {\n      e._latlng = t, this.removeLayer(e), e._latlng = i, this.addLayer(e);\n    },\n    _childMarkerDragEnd: function (e) {\n      var t = e.target.__dragStart;\n      delete e.target.__dragStart, t && this._moveChild(e.target, t, e.target._latlng);\n    },\n    _removeLayer: function (e, t, i) {\n      var n = this._gridClusters,\n          r = this._gridUnclustered,\n          s = this._featureGroup,\n          o = this._map,\n          a = Math.floor(this._map.getMinZoom());\n      t && this._removeFromGridUnclustered(e, this._maxZoom);\n      var h,\n          l = e.__parent,\n          u = l._markers;\n\n      for (this._arraySplice(u, e); l && (l._childCount--, l._boundsNeedUpdate = !0, !(l._zoom < a));) t && l._childCount <= 1 ? (h = l._markers[0] === e ? l._markers[1] : l._markers[0], n[l._zoom].removeObject(l, o.project(l._cLatLng, l._zoom)), r[l._zoom].addObject(h, o.project(h.getLatLng(), l._zoom)), this._arraySplice(l.__parent._childClusters, l), l.__parent._markers.push(h), h.__parent = l.__parent, l._icon && (s.removeLayer(l), i || s.addLayer(h))) : l._iconNeedsUpdate = !0, l = l.__parent;\n\n      delete e.__parent;\n    },\n    _isOrIsParent: function (e, t) {\n      for (; t;) {\n        if (e === t) return !0;\n        t = t.parentNode;\n      }\n\n      return !1;\n    },\n    fire: function (e, t, i) {\n      if (t && t.layer instanceof L.MarkerCluster) {\n        if (t.originalEvent && this._isOrIsParent(t.layer._icon, t.originalEvent.relatedTarget)) return;\n        e = \"cluster\" + e;\n      }\n\n      L.FeatureGroup.prototype.fire.call(this, e, t, i);\n    },\n    listens: function (e, t) {\n      return L.FeatureGroup.prototype.listens.call(this, e, t) || L.FeatureGroup.prototype.listens.call(this, \"cluster\" + e, t);\n    },\n    _defaultIconCreateFunction: function (e) {\n      var t = e.getChildCount(),\n          i = \" marker-cluster-\";\n      return i += 10 > t ? \"small\" : 100 > t ? \"medium\" : \"large\", new L.DivIcon({\n        html: \"<div><span>\" + t + \"</span></div>\",\n        className: \"marker-cluster\" + i,\n        iconSize: new L.Point(40, 40)\n      });\n    },\n    _bindEvents: function () {\n      var e = this._map,\n          t = this.options.spiderfyOnMaxZoom,\n          i = this.options.showCoverageOnHover,\n          n = this.options.zoomToBoundsOnClick;\n      (t || n) && this.on(\"clusterclick\", this._zoomOrSpiderfy, this), i && (this.on(\"clustermouseover\", this._showCoverage, this), this.on(\"clustermouseout\", this._hideCoverage, this), e.on(\"zoomend\", this._hideCoverage, this));\n    },\n    _zoomOrSpiderfy: function (e) {\n      for (var t = e.layer, i = t; 1 === i._childClusters.length;) i = i._childClusters[0];\n\n      i._zoom === this._maxZoom && i._childCount === t._childCount && this.options.spiderfyOnMaxZoom ? t.spiderfy() : this.options.zoomToBoundsOnClick && t.zoomToBounds(), e.originalEvent && 13 === e.originalEvent.keyCode && this._map._container.focus();\n    },\n    _showCoverage: function (e) {\n      var t = this._map;\n      this._inZoomAnimation || (this._shownPolygon && t.removeLayer(this._shownPolygon), e.layer.getChildCount() > 2 && e.layer !== this._spiderfied && (this._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions), t.addLayer(this._shownPolygon)));\n    },\n    _hideCoverage: function () {\n      this._shownPolygon && (this._map.removeLayer(this._shownPolygon), this._shownPolygon = null);\n    },\n    _unbindEvents: function () {\n      var e = this.options.spiderfyOnMaxZoom,\n          t = this.options.showCoverageOnHover,\n          i = this.options.zoomToBoundsOnClick,\n          n = this._map;\n      (e || i) && this.off(\"clusterclick\", this._zoomOrSpiderfy, this), t && (this.off(\"clustermouseover\", this._showCoverage, this), this.off(\"clustermouseout\", this._hideCoverage, this), n.off(\"zoomend\", this._hideCoverage, this));\n    },\n    _zoomEnd: function () {\n      this._map && (this._mergeSplitClusters(), this._zoom = Math.round(this._map._zoom), this._currentShownBounds = this._getExpandedVisibleBounds());\n    },\n    _moveEnd: function () {\n      if (!this._inZoomAnimation) {\n        var e = this._getExpandedVisibleBounds();\n\n        this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, e), this._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), e), this._currentShownBounds = e;\n      }\n    },\n    _generateInitialClusters: function () {\n      var e = Math.ceil(this._map.getMaxZoom()),\n          t = Math.floor(this._map.getMinZoom()),\n          i = this.options.maxClusterRadius,\n          n = i;\n      \"function\" != typeof i && (n = function () {\n        return i;\n      }), null !== this.options.disableClusteringAtZoom && (e = this.options.disableClusteringAtZoom - 1), this._maxZoom = e, this._gridClusters = {}, this._gridUnclustered = {};\n\n      for (var r = e; r >= t; r--) this._gridClusters[r] = new L.DistanceGrid(n(r)), this._gridUnclustered[r] = new L.DistanceGrid(n(r));\n\n      this._topClusterLevel = new this._markerCluster(this, t - 1);\n    },\n    _addLayer: function (e, t) {\n      var i,\n          n,\n          r = this._gridClusters,\n          s = this._gridUnclustered,\n          o = Math.floor(this._map.getMinZoom());\n\n      for (this.options.singleMarkerMode && this._overrideMarkerIcon(e), e.on(this._childMarkerEventHandlers, this); t >= o; t--) {\n        i = this._map.project(e.getLatLng(), t);\n        var a = r[t].getNearObject(i);\n        if (a) return a._addChild(e), e.__parent = a, void 0;\n\n        if (a = s[t].getNearObject(i)) {\n          var h = a.__parent;\n          h && this._removeLayer(a, !1);\n          var l = new this._markerCluster(this, t, a, e);\n          r[t].addObject(l, this._map.project(l._cLatLng, t)), a.__parent = l, e.__parent = l;\n          var u = l;\n\n          for (n = t - 1; n > h._zoom; n--) u = new this._markerCluster(this, n, u), r[n].addObject(u, this._map.project(a.getLatLng(), n));\n\n          return h._addChild(u), this._removeFromGridUnclustered(a, t), void 0;\n        }\n\n        s[t].addObject(e, i);\n      }\n\n      this._topClusterLevel._addChild(e), e.__parent = this._topClusterLevel;\n    },\n    _refreshClustersIcons: function () {\n      this._featureGroup.eachLayer(function (e) {\n        e instanceof L.MarkerCluster && e._iconNeedsUpdate && e._updateIcon();\n      });\n    },\n    _enqueue: function (e) {\n      this._queue.push(e), this._queueTimeout || (this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300));\n    },\n    _processQueue: function () {\n      for (var e = 0; e < this._queue.length; e++) this._queue[e].call(this);\n\n      this._queue.length = 0, clearTimeout(this._queueTimeout), this._queueTimeout = null;\n    },\n    _mergeSplitClusters: function () {\n      var e = Math.round(this._map._zoom);\n      this._processQueue(), this._zoom < e && this._currentShownBounds.intersects(this._getExpandedVisibleBounds()) ? (this._animationStart(), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds()), this._animationZoomIn(this._zoom, e)) : this._zoom > e ? (this._animationStart(), this._animationZoomOut(this._zoom, e)) : this._moveEnd();\n    },\n    _getExpandedVisibleBounds: function () {\n      return this.options.removeOutsideVisibleBounds ? L.Browser.mobile ? this._checkBoundsMaxLat(this._map.getBounds()) : this._checkBoundsMaxLat(this._map.getBounds().pad(1)) : this._mapBoundsInfinite;\n    },\n    _checkBoundsMaxLat: function (e) {\n      var t = this._maxLat;\n      return void 0 !== t && (e.getNorth() >= t && (e._northEast.lat = 1 / 0), e.getSouth() <= -t && (e._southWest.lat = -1 / 0)), e;\n    },\n    _animationAddLayerNonAnimated: function (e, t) {\n      if (t === e) this._featureGroup.addLayer(e);else if (2 === t._childCount) {\n        t._addToMap();\n\n        var i = t.getAllChildMarkers();\n        this._featureGroup.removeLayer(i[0]), this._featureGroup.removeLayer(i[1]);\n      } else t._updateIcon();\n    },\n    _extractNonGroupLayers: function (e, t) {\n      var i,\n          n = e.getLayers(),\n          r = 0;\n\n      for (t = t || []; r < n.length; r++) i = n[r], i instanceof L.LayerGroup ? this._extractNonGroupLayers(i, t) : t.push(i);\n\n      return t;\n    },\n    _overrideMarkerIcon: function (e) {\n      var t = e.options.icon = this.options.iconCreateFunction({\n        getChildCount: function () {\n          return 1;\n        },\n        getAllChildMarkers: function () {\n          return [e];\n        }\n      });\n      return t;\n    }\n  });\n  L.MarkerClusterGroup.include({\n    _mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-1 / 0, -1 / 0), new L.LatLng(1 / 0, 1 / 0))\n  }), L.MarkerClusterGroup.include({\n    _noAnimation: {\n      _animationStart: function () {},\n      _animationZoomIn: function (e, t) {\n        this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), e), this._topClusterLevel._recursivelyAddChildrenToMap(null, t, this._getExpandedVisibleBounds()), this.fire(\"animationend\");\n      },\n      _animationZoomOut: function (e, t) {\n        this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), e), this._topClusterLevel._recursivelyAddChildrenToMap(null, t, this._getExpandedVisibleBounds()), this.fire(\"animationend\");\n      },\n      _animationAddLayer: function (e, t) {\n        this._animationAddLayerNonAnimated(e, t);\n      }\n    },\n    _withAnimation: {\n      _animationStart: function () {\n        this._map._mapPane.className += \" leaflet-cluster-anim\", this._inZoomAnimation++;\n      },\n      _animationZoomIn: function (e, t) {\n        var i,\n            n = this._getExpandedVisibleBounds(),\n            r = this._featureGroup,\n            s = Math.floor(this._map.getMinZoom());\n\n        this._ignoreMove = !0, this._topClusterLevel._recursively(n, e, s, function (s) {\n          var o,\n              a = s._latlng,\n              h = s._markers;\n\n          for (n.contains(a) || (a = null), s._isSingleParent() && e + 1 === t ? (r.removeLayer(s), s._recursivelyAddChildrenToMap(null, t, n)) : (s.clusterHide(), s._recursivelyAddChildrenToMap(a, t, n)), i = h.length - 1; i >= 0; i--) o = h[i], n.contains(o._latlng) || r.removeLayer(o);\n        }), this._forceLayout(), this._topClusterLevel._recursivelyBecomeVisible(n, t), r.eachLayer(function (e) {\n          e instanceof L.MarkerCluster || !e._icon || e.clusterShow();\n        }), this._topClusterLevel._recursively(n, e, t, function (e) {\n          e._recursivelyRestoreChildPositions(t);\n        }), this._ignoreMove = !1, this._enqueue(function () {\n          this._topClusterLevel._recursively(n, e, s, function (e) {\n            r.removeLayer(e), e.clusterShow();\n          }), this._animationEnd();\n        });\n      },\n      _animationZoomOut: function (e, t) {\n        this._animationZoomOutSingle(this._topClusterLevel, e - 1, t), this._topClusterLevel._recursivelyAddChildrenToMap(null, t, this._getExpandedVisibleBounds()), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), e, this._getExpandedVisibleBounds());\n      },\n      _animationAddLayer: function (e, t) {\n        var i = this,\n            n = this._featureGroup;\n        n.addLayer(e), t !== e && (t._childCount > 2 ? (t._updateIcon(), this._forceLayout(), this._animationStart(), e._setPos(this._map.latLngToLayerPoint(t.getLatLng())), e.clusterHide(), this._enqueue(function () {\n          n.removeLayer(e), e.clusterShow(), i._animationEnd();\n        })) : (this._forceLayout(), i._animationStart(), i._animationZoomOutSingle(t, this._map.getMaxZoom(), this._zoom)));\n      }\n    },\n    _animationZoomOutSingle: function (e, t, i) {\n      var n = this._getExpandedVisibleBounds(),\n          r = Math.floor(this._map.getMinZoom());\n\n      e._recursivelyAnimateChildrenInAndAddSelfToMap(n, r, t + 1, i);\n\n      var s = this;\n      this._forceLayout(), e._recursivelyBecomeVisible(n, i), this._enqueue(function () {\n        if (1 === e._childCount) {\n          var o = e._markers[0];\n          this._ignoreMove = !0, o.setLatLng(o.getLatLng()), this._ignoreMove = !1, o.clusterShow && o.clusterShow();\n        } else e._recursively(n, i, r, function (e) {\n          e._recursivelyRemoveChildrenFromMap(n, r, t + 1);\n        });\n\n        s._animationEnd();\n      });\n    },\n    _animationEnd: function () {\n      this._map && (this._map._mapPane.className = this._map._mapPane.className.replace(\" leaflet-cluster-anim\", \"\")), this._inZoomAnimation--, this.fire(\"animationend\");\n    },\n    _forceLayout: function () {\n      L.Util.falseFn(document.body.offsetWidth);\n    }\n  }), L.markerClusterGroup = function (e) {\n    return new L.MarkerClusterGroup(e);\n  };\n  var i = L.MarkerCluster = L.Marker.extend({\n    options: L.Icon.prototype.options,\n    initialize: function (e, t, i, n) {\n      L.Marker.prototype.initialize.call(this, i ? i._cLatLng || i.getLatLng() : new L.LatLng(0, 0), {\n        icon: this,\n        pane: e.options.clusterPane\n      }), this._group = e, this._zoom = t, this._markers = [], this._childClusters = [], this._childCount = 0, this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._bounds = new L.LatLngBounds(), i && this._addChild(i), n && this._addChild(n);\n    },\n    getAllChildMarkers: function (e, t) {\n      e = e || [];\n\n      for (var i = this._childClusters.length - 1; i >= 0; i--) this._childClusters[i].getAllChildMarkers(e);\n\n      for (var n = this._markers.length - 1; n >= 0; n--) t && this._markers[n].__dragStart || e.push(this._markers[n]);\n\n      return e;\n    },\n    getChildCount: function () {\n      return this._childCount;\n    },\n    zoomToBounds: function (e) {\n      for (var t, i = this._childClusters.slice(), n = this._group._map, r = n.getBoundsZoom(this._bounds), s = this._zoom + 1, o = n.getZoom(); i.length > 0 && r > s;) {\n        s++;\n        var a = [];\n\n        for (t = 0; t < i.length; t++) a = a.concat(i[t]._childClusters);\n\n        i = a;\n      }\n\n      r > s ? this._group._map.setView(this._latlng, s) : o >= r ? this._group._map.setView(this._latlng, o + 1) : this._group._map.fitBounds(this._bounds, e);\n    },\n    getBounds: function () {\n      var e = new L.LatLngBounds();\n      return e.extend(this._bounds), e;\n    },\n    _updateIcon: function () {\n      this._iconNeedsUpdate = !0, this._icon && this.setIcon(this);\n    },\n    createIcon: function () {\n      return this._iconNeedsUpdate && (this._iconObj = this._group.options.iconCreateFunction(this), this._iconNeedsUpdate = !1), this._iconObj.createIcon();\n    },\n    createShadow: function () {\n      return this._iconObj.createShadow();\n    },\n    _addChild: function (e, t) {\n      this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._setClusterCenter(e), e instanceof L.MarkerCluster ? (t || (this._childClusters.push(e), e.__parent = this), this._childCount += e._childCount) : (t || this._markers.push(e), this._childCount++), this.__parent && this.__parent._addChild(e, !0);\n    },\n    _setClusterCenter: function (e) {\n      this._cLatLng || (this._cLatLng = e._cLatLng || e._latlng);\n    },\n    _resetBounds: function () {\n      var e = this._bounds;\n      e._southWest && (e._southWest.lat = 1 / 0, e._southWest.lng = 1 / 0), e._northEast && (e._northEast.lat = -1 / 0, e._northEast.lng = -1 / 0);\n    },\n    _recalculateBounds: function () {\n      var e,\n          t,\n          i,\n          n,\n          r = this._markers,\n          s = this._childClusters,\n          o = 0,\n          a = 0,\n          h = this._childCount;\n\n      if (0 !== h) {\n        for (this._resetBounds(), e = 0; e < r.length; e++) i = r[e]._latlng, this._bounds.extend(i), o += i.lat, a += i.lng;\n\n        for (e = 0; e < s.length; e++) t = s[e], t._boundsNeedUpdate && t._recalculateBounds(), this._bounds.extend(t._bounds), i = t._wLatLng, n = t._childCount, o += i.lat * n, a += i.lng * n;\n\n        this._latlng = this._wLatLng = new L.LatLng(o / h, a / h), this._boundsNeedUpdate = !1;\n      }\n    },\n    _addToMap: function (e) {\n      e && (this._backupLatlng = this._latlng, this.setLatLng(e)), this._group._featureGroup.addLayer(this);\n    },\n    _recursivelyAnimateChildrenIn: function (e, t, i) {\n      this._recursively(e, this._group._map.getMinZoom(), i - 1, function (e) {\n        var i,\n            n,\n            r = e._markers;\n\n        for (i = r.length - 1; i >= 0; i--) n = r[i], n._icon && (n._setPos(t), n.clusterHide());\n      }, function (e) {\n        var i,\n            n,\n            r = e._childClusters;\n\n        for (i = r.length - 1; i >= 0; i--) n = r[i], n._icon && (n._setPos(t), n.clusterHide());\n      });\n    },\n    _recursivelyAnimateChildrenInAndAddSelfToMap: function (e, t, i, n) {\n      this._recursively(e, n, t, function (r) {\n        r._recursivelyAnimateChildrenIn(e, r._group._map.latLngToLayerPoint(r.getLatLng()).round(), i), r._isSingleParent() && i - 1 === n ? (r.clusterShow(), r._recursivelyRemoveChildrenFromMap(e, t, i)) : r.clusterHide(), r._addToMap();\n      });\n    },\n    _recursivelyBecomeVisible: function (e, t) {\n      this._recursively(e, this._group._map.getMinZoom(), t, null, function (e) {\n        e.clusterShow();\n      });\n    },\n    _recursivelyAddChildrenToMap: function (e, t, i) {\n      this._recursively(i, this._group._map.getMinZoom() - 1, t, function (n) {\n        if (t !== n._zoom) for (var r = n._markers.length - 1; r >= 0; r--) {\n          var s = n._markers[r];\n          i.contains(s._latlng) && (e && (s._backupLatlng = s.getLatLng(), s.setLatLng(e), s.clusterHide && s.clusterHide()), n._group._featureGroup.addLayer(s));\n        }\n      }, function (t) {\n        t._addToMap(e);\n      });\n    },\n    _recursivelyRestoreChildPositions: function (e) {\n      for (var t = this._markers.length - 1; t >= 0; t--) {\n        var i = this._markers[t];\n        i._backupLatlng && (i.setLatLng(i._backupLatlng), delete i._backupLatlng);\n      }\n\n      if (e - 1 === this._zoom) for (var n = this._childClusters.length - 1; n >= 0; n--) this._childClusters[n]._restorePosition();else for (var r = this._childClusters.length - 1; r >= 0; r--) this._childClusters[r]._recursivelyRestoreChildPositions(e);\n    },\n    _restorePosition: function () {\n      this._backupLatlng && (this.setLatLng(this._backupLatlng), delete this._backupLatlng);\n    },\n    _recursivelyRemoveChildrenFromMap: function (e, t, i, n) {\n      var r, s;\n\n      this._recursively(e, t - 1, i - 1, function (e) {\n        for (s = e._markers.length - 1; s >= 0; s--) r = e._markers[s], n && n.contains(r._latlng) || (e._group._featureGroup.removeLayer(r), r.clusterShow && r.clusterShow());\n      }, function (e) {\n        for (s = e._childClusters.length - 1; s >= 0; s--) r = e._childClusters[s], n && n.contains(r._latlng) || (e._group._featureGroup.removeLayer(r), r.clusterShow && r.clusterShow());\n      });\n    },\n    _recursively: function (e, t, i, n, r) {\n      var s,\n          o,\n          a = this._childClusters,\n          h = this._zoom;\n      if (h >= t && (n && n(this), r && h === i && r(this)), t > h || i > h) for (s = a.length - 1; s >= 0; s--) o = a[s], o._boundsNeedUpdate && o._recalculateBounds(), e.intersects(o._bounds) && o._recursively(e, t, i, n, r);\n    },\n    _isSingleParent: function () {\n      return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;\n    }\n  });\n  L.Marker.include({\n    clusterHide: function () {\n      var e = this.options.opacity;\n      return this.setOpacity(0), this.options.opacity = e, this;\n    },\n    clusterShow: function () {\n      return this.setOpacity(this.options.opacity);\n    }\n  }), L.DistanceGrid = function (e) {\n    this._cellSize = e, this._sqCellSize = e * e, this._grid = {}, this._objectPoint = {};\n  }, L.DistanceGrid.prototype = {\n    addObject: function (e, t) {\n      var i = this._getCoord(t.x),\n          n = this._getCoord(t.y),\n          r = this._grid,\n          s = r[n] = r[n] || {},\n          o = s[i] = s[i] || [],\n          a = L.Util.stamp(e);\n\n      this._objectPoint[a] = t, o.push(e);\n    },\n    updateObject: function (e, t) {\n      this.removeObject(e), this.addObject(e, t);\n    },\n    removeObject: function (e, t) {\n      var i,\n          n,\n          r = this._getCoord(t.x),\n          s = this._getCoord(t.y),\n          o = this._grid,\n          a = o[s] = o[s] || {},\n          h = a[r] = a[r] || [];\n\n      for (delete this._objectPoint[L.Util.stamp(e)], i = 0, n = h.length; n > i; i++) if (h[i] === e) return h.splice(i, 1), 1 === n && delete a[r], !0;\n    },\n    eachObject: function (e, t) {\n      var i,\n          n,\n          r,\n          s,\n          o,\n          a,\n          h,\n          l = this._grid;\n\n      for (i in l) {\n        o = l[i];\n\n        for (n in o) for (a = o[n], r = 0, s = a.length; s > r; r++) h = e.call(t, a[r]), h && (r--, s--);\n      }\n    },\n    getNearObject: function (e) {\n      var t,\n          i,\n          n,\n          r,\n          s,\n          o,\n          a,\n          h,\n          l = this._getCoord(e.x),\n          u = this._getCoord(e.y),\n          _ = this._objectPoint,\n          d = this._sqCellSize,\n          c = null;\n\n      for (t = u - 1; u + 1 >= t; t++) if (r = this._grid[t]) for (i = l - 1; l + 1 >= i; i++) if (s = r[i]) for (n = 0, o = s.length; o > n; n++) a = s[n], h = this._sqDist(_[L.Util.stamp(a)], e), (d > h || d >= h && null === c) && (d = h, c = a);\n\n      return c;\n    },\n    _getCoord: function (e) {\n      var t = Math.floor(e / this._cellSize);\n      return isFinite(t) ? t : e;\n    },\n    _sqDist: function (e, t) {\n      var i = t.x - e.x,\n          n = t.y - e.y;\n      return i * i + n * n;\n    }\n  }, function () {\n    L.QuickHull = {\n      getDistant: function (e, t) {\n        var i = t[1].lat - t[0].lat,\n            n = t[0].lng - t[1].lng;\n        return n * (e.lat - t[0].lat) + i * (e.lng - t[0].lng);\n      },\n      findMostDistantPointFromBaseLine: function (e, t) {\n        var i,\n            n,\n            r,\n            s = 0,\n            o = null,\n            a = [];\n\n        for (i = t.length - 1; i >= 0; i--) n = t[i], r = this.getDistant(n, e), r > 0 && (a.push(n), r > s && (s = r, o = n));\n\n        return {\n          maxPoint: o,\n          newPoints: a\n        };\n      },\n      buildConvexHull: function (e, t) {\n        var i = [],\n            n = this.findMostDistantPointFromBaseLine(e, t);\n        return n.maxPoint ? (i = i.concat(this.buildConvexHull([e[0], n.maxPoint], n.newPoints)), i = i.concat(this.buildConvexHull([n.maxPoint, e[1]], n.newPoints))) : [e[0]];\n      },\n      getConvexHull: function (e) {\n        var t,\n            i = !1,\n            n = !1,\n            r = !1,\n            s = !1,\n            o = null,\n            a = null,\n            h = null,\n            l = null,\n            u = null,\n            _ = null;\n\n        for (t = e.length - 1; t >= 0; t--) {\n          var d = e[t];\n          (i === !1 || d.lat > i) && (o = d, i = d.lat), (n === !1 || d.lat < n) && (a = d, n = d.lat), (r === !1 || d.lng > r) && (h = d, r = d.lng), (s === !1 || d.lng < s) && (l = d, s = d.lng);\n        }\n\n        n !== i ? (_ = a, u = o) : (_ = l, u = h);\n        var c = [].concat(this.buildConvexHull([_, u], e), this.buildConvexHull([u, _], e));\n        return c;\n      }\n    };\n  }(), L.MarkerCluster.include({\n    getConvexHull: function () {\n      var e,\n          t,\n          i = this.getAllChildMarkers(),\n          n = [];\n\n      for (t = i.length - 1; t >= 0; t--) e = i[t].getLatLng(), n.push(e);\n\n      return L.QuickHull.getConvexHull(n);\n    }\n  }), L.MarkerCluster.include({\n    _2PI: 2 * Math.PI,\n    _circleFootSeparation: 25,\n    _circleStartAngle: 0,\n    _spiralFootSeparation: 28,\n    _spiralLengthStart: 11,\n    _spiralLengthFactor: 5,\n    _circleSpiralSwitchover: 9,\n    spiderfy: function () {\n      if (this._group._spiderfied !== this && !this._group._inZoomAnimation) {\n        var e,\n            t = this.getAllChildMarkers(null, !0),\n            i = this._group,\n            n = i._map,\n            r = n.latLngToLayerPoint(this._latlng);\n        this._group._unspiderfy(), this._group._spiderfied = this, t.length >= this._circleSpiralSwitchover ? e = this._generatePointsSpiral(t.length, r) : (r.y += 10, e = this._generatePointsCircle(t.length, r)), this._animationSpiderfy(t, e);\n      }\n    },\n    unspiderfy: function (e) {\n      this._group._inZoomAnimation || (this._animationUnspiderfy(e), this._group._spiderfied = null);\n    },\n    _generatePointsCircle: function (e, t) {\n      var i,\n          n,\n          r = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + e),\n          s = r / this._2PI,\n          o = this._2PI / e,\n          a = [];\n\n      for (s = Math.max(s, 35), a.length = e, i = 0; e > i; i++) n = this._circleStartAngle + i * o, a[i] = new L.Point(t.x + s * Math.cos(n), t.y + s * Math.sin(n))._round();\n\n      return a;\n    },\n    _generatePointsSpiral: function (e, t) {\n      var i,\n          n = this._group.options.spiderfyDistanceMultiplier,\n          r = n * this._spiralLengthStart,\n          s = n * this._spiralFootSeparation,\n          o = n * this._spiralLengthFactor * this._2PI,\n          a = 0,\n          h = [];\n\n      for (h.length = e, i = e; i >= 0; i--) e > i && (h[i] = new L.Point(t.x + r * Math.cos(a), t.y + r * Math.sin(a))._round()), a += s / r + 5e-4 * i, r += o / a;\n\n      return h;\n    },\n    _noanimationUnspiderfy: function () {\n      var e,\n          t,\n          i = this._group,\n          n = i._map,\n          r = i._featureGroup,\n          s = this.getAllChildMarkers(null, !0);\n\n      for (i._ignoreMove = !0, this.setOpacity(1), t = s.length - 1; t >= 0; t--) e = s[t], r.removeLayer(e), e._preSpiderfyLatlng && (e.setLatLng(e._preSpiderfyLatlng), delete e._preSpiderfyLatlng), e.setZIndexOffset && e.setZIndexOffset(0), e._spiderLeg && (n.removeLayer(e._spiderLeg), delete e._spiderLeg);\n\n      i.fire(\"unspiderfied\", {\n        cluster: this,\n        markers: s\n      }), i._ignoreMove = !1, i._spiderfied = null;\n    }\n  }), L.MarkerClusterNonAnimated = L.MarkerCluster.extend({\n    _animationSpiderfy: function (e, t) {\n      var i,\n          n,\n          r,\n          s,\n          o = this._group,\n          a = o._map,\n          h = o._featureGroup,\n          l = this._group.options.spiderLegPolylineOptions;\n\n      for (o._ignoreMove = !0, i = 0; i < e.length; i++) s = a.layerPointToLatLng(t[i]), n = e[i], r = new L.Polyline([this._latlng, s], l), a.addLayer(r), n._spiderLeg = r, n._preSpiderfyLatlng = n._latlng, n.setLatLng(s), n.setZIndexOffset && n.setZIndexOffset(1e6), h.addLayer(n);\n\n      this.setOpacity(.3), o._ignoreMove = !1, o.fire(\"spiderfied\", {\n        cluster: this,\n        markers: e\n      });\n    },\n    _animationUnspiderfy: function () {\n      this._noanimationUnspiderfy();\n    }\n  }), L.MarkerCluster.include({\n    _animationSpiderfy: function (e, t) {\n      var i,\n          n,\n          r,\n          s,\n          o,\n          a,\n          h = this,\n          l = this._group,\n          u = l._map,\n          _ = l._featureGroup,\n          d = this._latlng,\n          c = u.latLngToLayerPoint(d),\n          p = L.Path.SVG,\n          f = L.extend({}, this._group.options.spiderLegPolylineOptions),\n          m = f.opacity;\n\n      for (void 0 === m && (m = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity), p ? (f.opacity = 0, f.className = (f.className || \"\") + \" leaflet-cluster-spider-leg\") : f.opacity = m, l._ignoreMove = !0, i = 0; i < e.length; i++) n = e[i], a = u.layerPointToLatLng(t[i]), r = new L.Polyline([d, a], f), u.addLayer(r), n._spiderLeg = r, p && (s = r._path, o = s.getTotalLength() + .1, s.style.strokeDasharray = o, s.style.strokeDashoffset = o), n.setZIndexOffset && n.setZIndexOffset(1e6), n.clusterHide && n.clusterHide(), _.addLayer(n), n._setPos && n._setPos(c);\n\n      for (l._forceLayout(), l._animationStart(), i = e.length - 1; i >= 0; i--) a = u.layerPointToLatLng(t[i]), n = e[i], n._preSpiderfyLatlng = n._latlng, n.setLatLng(a), n.clusterShow && n.clusterShow(), p && (r = n._spiderLeg, s = r._path, s.style.strokeDashoffset = 0, r.setStyle({\n        opacity: m\n      }));\n\n      this.setOpacity(.3), l._ignoreMove = !1, setTimeout(function () {\n        l._animationEnd(), l.fire(\"spiderfied\", {\n          cluster: h,\n          markers: e\n        });\n      }, 200);\n    },\n    _animationUnspiderfy: function (e) {\n      var t,\n          i,\n          n,\n          r,\n          s,\n          o,\n          a = this,\n          h = this._group,\n          l = h._map,\n          u = h._featureGroup,\n          _ = e ? l._latLngToNewLayerPoint(this._latlng, e.zoom, e.center) : l.latLngToLayerPoint(this._latlng),\n          d = this.getAllChildMarkers(null, !0),\n          c = L.Path.SVG;\n\n      for (h._ignoreMove = !0, h._animationStart(), this.setOpacity(1), i = d.length - 1; i >= 0; i--) t = d[i], t._preSpiderfyLatlng && (t.closePopup(), t.setLatLng(t._preSpiderfyLatlng), delete t._preSpiderfyLatlng, o = !0, t._setPos && (t._setPos(_), o = !1), t.clusterHide && (t.clusterHide(), o = !1), o && u.removeLayer(t), c && (n = t._spiderLeg, r = n._path, s = r.getTotalLength() + .1, r.style.strokeDashoffset = s, n.setStyle({\n        opacity: 0\n      })));\n\n      h._ignoreMove = !1, setTimeout(function () {\n        var e = 0;\n\n        for (i = d.length - 1; i >= 0; i--) t = d[i], t._spiderLeg && e++;\n\n        for (i = d.length - 1; i >= 0; i--) t = d[i], t._spiderLeg && (t.clusterShow && t.clusterShow(), t.setZIndexOffset && t.setZIndexOffset(0), e > 1 && u.removeLayer(t), l.removeLayer(t._spiderLeg), delete t._spiderLeg);\n\n        h._animationEnd(), h.fire(\"unspiderfied\", {\n          cluster: a,\n          markers: d\n        });\n      }, 200);\n    }\n  }), L.MarkerClusterGroup.include({\n    _spiderfied: null,\n    unspiderfy: function () {\n      this._unspiderfy.apply(this, arguments);\n    },\n    _spiderfierOnAdd: function () {\n      this._map.on(\"click\", this._unspiderfyWrapper, this), this._map.options.zoomAnimation && this._map.on(\"zoomstart\", this._unspiderfyZoomStart, this), this._map.on(\"zoomend\", this._noanimationUnspiderfy, this), L.Browser.touch || this._map.getRenderer(this);\n    },\n    _spiderfierOnRemove: function () {\n      this._map.off(\"click\", this._unspiderfyWrapper, this), this._map.off(\"zoomstart\", this._unspiderfyZoomStart, this), this._map.off(\"zoomanim\", this._unspiderfyZoomAnim, this), this._map.off(\"zoomend\", this._noanimationUnspiderfy, this), this._noanimationUnspiderfy();\n    },\n    _unspiderfyZoomStart: function () {\n      this._map && this._map.on(\"zoomanim\", this._unspiderfyZoomAnim, this);\n    },\n    _unspiderfyZoomAnim: function (e) {\n      L.DomUtil.hasClass(this._map._mapPane, \"leaflet-touching\") || (this._map.off(\"zoomanim\", this._unspiderfyZoomAnim, this), this._unspiderfy(e));\n    },\n    _unspiderfyWrapper: function () {\n      this._unspiderfy();\n    },\n    _unspiderfy: function (e) {\n      this._spiderfied && this._spiderfied.unspiderfy(e);\n    },\n    _noanimationUnspiderfy: function () {\n      this._spiderfied && this._spiderfied._noanimationUnspiderfy();\n    },\n    _unspiderfyLayer: function (e) {\n      e._spiderLeg && (this._featureGroup.removeLayer(e), e.clusterShow && e.clusterShow(), e.setZIndexOffset && e.setZIndexOffset(0), this._map.removeLayer(e._spiderLeg), delete e._spiderLeg);\n    }\n  }), L.MarkerClusterGroup.include({\n    refreshClusters: function (e) {\n      return e ? e instanceof L.MarkerClusterGroup ? e = e._topClusterLevel.getAllChildMarkers() : e instanceof L.LayerGroup ? e = e._layers : e instanceof L.MarkerCluster ? e = e.getAllChildMarkers() : e instanceof L.Marker && (e = [e]) : e = this._topClusterLevel.getAllChildMarkers(), this._flagParentsIconsNeedUpdate(e), this._refreshClustersIcons(), this.options.singleMarkerMode && this._refreshSingleMarkerModeMarkers(e), this;\n    },\n    _flagParentsIconsNeedUpdate: function (e) {\n      var t, i;\n\n      for (t in e) for (i = e[t].__parent; i;) i._iconNeedsUpdate = !0, i = i.__parent;\n    },\n    _refreshSingleMarkerModeMarkers: function (e) {\n      var t, i;\n\n      for (t in e) i = e[t], this.hasLayer(i) && i.setIcon(this._overrideMarkerIcon(i));\n    }\n  }), L.Marker.include({\n    refreshIconOptions: function (e, t) {\n      var i = this.options.icon;\n      return L.setOptions(i, e), this.setIcon(i), t && this.__parent && this.__parent._group.refreshClusters(this), this;\n    }\n  }), e.MarkerClusterGroup = t, e.MarkerCluster = i;\n});","map":null,"metadata":{},"sourceType":"script"}