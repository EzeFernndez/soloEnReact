{"ast":null,"code":"/*! (c) Andrea Giammarchi - ISC */\nvar self = this ||\n/* istanbul ignore next */\n{};\n\ntry {\n  (function (URLSearchParams, plus) {\n    if (new URLSearchParams('q=%2B').get('q') !== plus || new URLSearchParams({\n      q: plus\n    }).get('q') !== plus || new URLSearchParams([['q', plus]]).get('q') !== plus || new URLSearchParams('q=\\n').toString() !== 'q=%0A' || new URLSearchParams({\n      q: ' &'\n    }).toString() !== 'q=+%26') throw URLSearchParams;\n    self.URLSearchParams = URLSearchParams;\n  })(URLSearchParams, '+');\n} catch (URLSearchParams) {\n  (function (Object, String, isArray) {\n    'use strict';\n\n    var create = Object.create;\n    var defineProperty = Object.defineProperty;\n    var find = /[!'\\(\\)~]|%20|%00/g;\n    var plus = /\\+/g;\n    var replace = {\n      '!': '%21',\n      \"'\": '%27',\n      '(': '%28',\n      ')': '%29',\n      '~': '%7E',\n      '%20': '+',\n      '%00': '\\x00'\n    };\n    var proto = {\n      append: function (key, value) {\n        appendTo(this._ungap, key, value);\n      },\n      delete: function (key) {\n        delete this._ungap[key];\n      },\n      get: function (key) {\n        return this.has(key) ? this._ungap[key][0] : null;\n      },\n      getAll: function (key) {\n        return this.has(key) ? this._ungap[key].slice(0) : [];\n      },\n      has: function (key) {\n        return key in this._ungap;\n      },\n      set: function (key, value) {\n        this._ungap[key] = [String(value)];\n      },\n      forEach: function (callback, thisArg) {\n        var self = this;\n\n        for (var key in self._ungap) self._ungap[key].forEach(invoke, key);\n\n        function invoke(value) {\n          callback.call(thisArg, value, String(key), self);\n        }\n      },\n      toJSON: function () {\n        return {};\n      },\n      toString: function () {\n        var query = [];\n\n        for (var key in this._ungap) {\n          var encoded = encode(key);\n\n          for (var i = 0, value = this._ungap[key]; i < value.length; i++) {\n            query.push(encoded + '=' + encode(value[i]));\n          }\n        }\n\n        return query.join('&');\n      }\n    };\n\n    for (var key in proto) defineProperty(URLSearchParams.prototype, key, {\n      configurable: true,\n      writable: true,\n      value: proto[key]\n    });\n\n    self.URLSearchParams = URLSearchParams;\n\n    function URLSearchParams(query) {\n      var dict = create(null);\n      defineProperty(this, '_ungap', {\n        value: dict\n      });\n\n      switch (true) {\n        case !query:\n          break;\n\n        case typeof query === 'string':\n          if (query.charAt(0) === '?') {\n            query = query.slice(1);\n          }\n\n          for (var pairs = query.split('&'), i = 0, length = pairs.length; i < length; i++) {\n            var value = pairs[i];\n            var index = value.indexOf('=');\n\n            if (-1 < index) {\n              appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));\n            } else if (value.length) {\n              appendTo(dict, decode(value), '');\n            }\n          }\n\n          break;\n\n        case isArray(query):\n          for (var i = 0, length = query.length; i < length; i++) {\n            var value = query[i];\n            appendTo(dict, value[0], value[1]);\n          }\n\n          break;\n\n        case 'forEach' in query:\n          query.forEach(addEach, dict);\n          break;\n\n        default:\n          for (var key in query) appendTo(dict, key, query[key]);\n\n      }\n    }\n\n    function addEach(value, key) {\n      appendTo(this, key, value);\n    }\n\n    function appendTo(dict, key, value) {\n      var res = isArray(value) ? value.join(',') : value;\n      if (key in dict) dict[key].push(res);else dict[key] = [res];\n    }\n\n    function decode(str) {\n      return decodeURIComponent(str.replace(plus, ' '));\n    }\n\n    function encode(str) {\n      return encodeURIComponent(str).replace(find, replacer);\n    }\n\n    function replacer(match) {\n      return replace[match];\n    }\n  })(Object, String, Array.isArray);\n}\n\n(function (URLSearchParamsProto) {\n  var iterable = false;\n\n  try {\n    iterable = !!Symbol.iterator;\n  } catch (o_O) {}\n  /* istanbul ignore else */\n\n\n  if (!('forEach' in URLSearchParamsProto)) {\n    URLSearchParamsProto.forEach = function forEach(callback, thisArg) {\n      var self = this;\n      var names = Object.create(null);\n      this.toString().replace(/=[\\s\\S]*?(?:&|$)/g, '=').split('=').forEach(function (name) {\n        if (!name.length || name in names) return;\n        (names[name] = self.getAll(name)).forEach(function (value) {\n          callback.call(thisArg, value, name, self);\n        });\n      });\n    };\n  }\n  /* istanbul ignore else */\n\n\n  if (!('keys' in URLSearchParamsProto)) {\n    URLSearchParamsProto.keys = function keys() {\n      return iterator(this, function (value, key) {\n        this.push(key);\n      });\n    };\n  }\n  /* istanbul ignore else */\n\n\n  if (!('values' in URLSearchParamsProto)) {\n    URLSearchParamsProto.values = function values() {\n      return iterator(this, function (value, key) {\n        this.push(value);\n      });\n    };\n  }\n  /* istanbul ignore else */\n\n\n  if (!('entries' in URLSearchParamsProto)) {\n    URLSearchParamsProto.entries = function entries() {\n      return iterator(this, function (value, key) {\n        this.push([key, value]);\n      });\n    };\n  }\n  /* istanbul ignore else */\n\n\n  if (iterable && !(Symbol.iterator in URLSearchParamsProto)) {\n    URLSearchParamsProto[Symbol.iterator] = URLSearchParamsProto.entries;\n  }\n  /* istanbul ignore else */\n\n\n  if (!('sort' in URLSearchParamsProto)) {\n    URLSearchParamsProto.sort = function sort() {\n      var entries = this.entries(),\n          entry = entries.next(),\n          done = entry.done,\n          keys = [],\n          values = Object.create(null),\n          i,\n          key,\n          value;\n\n      while (!done) {\n        value = entry.value;\n        key = value[0];\n        keys.push(key);\n\n        if (!(key in values)) {\n          values[key] = [];\n        }\n\n        values[key].push(value[1]);\n        entry = entries.next();\n        done = entry.done;\n      } // not the champion in efficiency\n      // but these two bits just do the job\n\n\n      keys.sort();\n\n      for (i = 0; i < keys.length; i++) {\n        this.delete(keys[i]);\n      }\n\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        this.append(key, values[key].shift());\n      }\n    };\n  }\n\n  function iterator(self, callback) {\n    var items = [];\n    self.forEach(callback, items);\n    return iterable ? items[Symbol.iterator]() : {\n      next: function () {\n        var value = items.shift();\n        return {\n          done: value === undefined,\n          value: value\n        };\n      }\n    };\n  }\n  /* istanbul ignore next */\n\n\n  (function (Object) {\n    var dP = Object.defineProperty,\n        gOPD = Object.getOwnPropertyDescriptor,\n        createSearchParamsPollute = function (search) {\n      function append(name, value) {\n        URLSearchParamsProto.append.call(this, name, value);\n        name = this.toString();\n        search.set.call(this._usp, name ? '?' + name : '');\n      }\n\n      function del(name) {\n        URLSearchParamsProto.delete.call(this, name);\n        name = this.toString();\n        search.set.call(this._usp, name ? '?' + name : '');\n      }\n\n      function set(name, value) {\n        URLSearchParamsProto.set.call(this, name, value);\n        name = this.toString();\n        search.set.call(this._usp, name ? '?' + name : '');\n      }\n\n      return function (sp, value) {\n        sp.append = append;\n        sp.delete = del;\n        sp.set = set;\n        return dP(sp, '_usp', {\n          configurable: true,\n          writable: true,\n          value: value\n        });\n      };\n    },\n        createSearchParamsCreate = function (polluteSearchParams) {\n      return function (obj, sp) {\n        dP(obj, '_searchParams', {\n          configurable: true,\n          writable: true,\n          value: polluteSearchParams(sp, obj)\n        });\n        return sp;\n      };\n    },\n        updateSearchParams = function (sp) {\n      var append = sp.append;\n      sp.append = URLSearchParamsProto.append;\n      URLSearchParams.call(sp, sp._usp.search.slice(1));\n      sp.append = append;\n    },\n        verifySearchParams = function (obj, Class) {\n      if (!(obj instanceof Class)) throw new TypeError(\"'searchParams' accessed on an object that \" + \"does not implement interface \" + Class.name);\n    },\n        upgradeClass = function (Class) {\n      var ClassProto = Class.prototype,\n          searchParams = gOPD(ClassProto, 'searchParams'),\n          href = gOPD(ClassProto, 'href'),\n          search = gOPD(ClassProto, 'search'),\n          createSearchParams;\n\n      if (!searchParams && search && search.set) {\n        createSearchParams = createSearchParamsCreate(createSearchParamsPollute(search));\n        Object.defineProperties(ClassProto, {\n          href: {\n            get: function () {\n              return href.get.call(this);\n            },\n            set: function (value) {\n              var sp = this._searchParams;\n              href.set.call(this, value);\n              if (sp) updateSearchParams(sp);\n            }\n          },\n          search: {\n            get: function () {\n              return search.get.call(this);\n            },\n            set: function (value) {\n              var sp = this._searchParams;\n              search.set.call(this, value);\n              if (sp) updateSearchParams(sp);\n            }\n          },\n          searchParams: {\n            get: function () {\n              verifySearchParams(this, Class);\n              return this._searchParams || createSearchParams(this, new URLSearchParams(this.search.slice(1)));\n            },\n            set: function (sp) {\n              verifySearchParams(this, Class);\n              createSearchParams(this, sp);\n            }\n          }\n        });\n      }\n    };\n\n    try {\n      upgradeClass(HTMLAnchorElement);\n      if (/^function|object$/.test(typeof URL) && URL.prototype) upgradeClass(URL);\n    } catch (meh) {}\n  })(Object);\n})(self.URLSearchParams.prototype, Object);\n\nexport default self.URLSearchParams;","map":null,"metadata":{},"sourceType":"module"}