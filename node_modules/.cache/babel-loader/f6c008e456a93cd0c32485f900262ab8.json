{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('leaflet'), require('react-dom')) : typeof define === 'function' && define.amd ? define(['exports', 'react', 'leaflet', 'react-dom'], factory) : (global = global || self, factory(global.ReactLeaflet = {}, global.React, global.L, global.ReactDOM));\n})(this, function (exports, React, leaflet, reactDom) {\n  'use strict';\n\n  var React__default = 'default' in React ? React['default'] : React;\n\n  function unwrapExports(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n  }\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var _extends_1 = createCommonjsModule(function (module) {\n    function _extends() {\n      module.exports = _extends = Object.assign || function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n      return _extends.apply(this, arguments);\n    }\n\n    module.exports = _extends;\n  });\n\n  var reactIs_development = createCommonjsModule(function (module, exports) {\n    {\n      (function () {\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        }); // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n        // nor polyfill, then a plain number is used for performance.\n\n        var hasSymbol = typeof Symbol === 'function' && Symbol.for;\n        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\n        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\n        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\n        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\n        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\n        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\n        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;\n        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\n        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\n        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\n        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\n        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\n        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\n\n        function isValidElementType(type) {\n          return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);\n        }\n        /**\n         * Forked from fbjs/warning:\n         * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n         *\n         * Only change is we use console.warn instead of console.error,\n         * and do nothing when 'console' is not supported.\n         * This really simplifies the code.\n         * ---\n         * Similar to invariant but only logs a warning if the condition is not met.\n         * This can be used to log issues in development environments in critical\n         * paths. Removing the logging code for production environments will keep the\n         * same logic and follow the same code paths.\n         */\n\n\n        var lowPriorityWarning = function () {};\n\n        {\n          var printWarning = function (format) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n              args[_key - 1] = arguments[_key];\n            }\n\n            var argIndex = 0;\n            var message = 'Warning: ' + format.replace(/%s/g, function () {\n              return args[argIndex++];\n            });\n\n            if (typeof console !== 'undefined') {\n              console.warn(message);\n            }\n\n            try {\n              // --- Welcome to debugging React ---\n              // This error was thrown as a convenience so that you can use this stack\n              // to find the callsite that caused this warning to fire.\n              throw new Error(message);\n            } catch (x) {}\n          };\n\n          lowPriorityWarning = function (condition, format) {\n            if (format === undefined) {\n              throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');\n            }\n\n            if (!condition) {\n              for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n                args[_key2 - 2] = arguments[_key2];\n              }\n\n              printWarning.apply(undefined, [format].concat(args));\n            }\n          };\n        }\n        var lowPriorityWarning$1 = lowPriorityWarning;\n\n        function typeOf(object) {\n          if (typeof object === 'object' && object !== null) {\n            var $$typeof = object.$$typeof;\n\n            switch ($$typeof) {\n              case REACT_ELEMENT_TYPE:\n                var type = object.type;\n\n                switch (type) {\n                  case REACT_ASYNC_MODE_TYPE:\n                  case REACT_CONCURRENT_MODE_TYPE:\n                  case REACT_FRAGMENT_TYPE:\n                  case REACT_PROFILER_TYPE:\n                  case REACT_STRICT_MODE_TYPE:\n                  case REACT_SUSPENSE_TYPE:\n                    return type;\n\n                  default:\n                    var $$typeofType = type && type.$$typeof;\n\n                    switch ($$typeofType) {\n                      case REACT_CONTEXT_TYPE:\n                      case REACT_FORWARD_REF_TYPE:\n                      case REACT_PROVIDER_TYPE:\n                        return $$typeofType;\n\n                      default:\n                        return $$typeof;\n                    }\n\n                }\n\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PORTAL_TYPE:\n                return $$typeof;\n            }\n          }\n\n          return undefined;\n        } // AsyncMode is deprecated along with isAsyncMode\n\n\n        var AsyncMode = REACT_ASYNC_MODE_TYPE;\n        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\n        var ContextConsumer = REACT_CONTEXT_TYPE;\n        var ContextProvider = REACT_PROVIDER_TYPE;\n        var Element = REACT_ELEMENT_TYPE;\n        var ForwardRef = REACT_FORWARD_REF_TYPE;\n        var Fragment = REACT_FRAGMENT_TYPE;\n        var Lazy = REACT_LAZY_TYPE;\n        var Memo = REACT_MEMO_TYPE;\n        var Portal = REACT_PORTAL_TYPE;\n        var Profiler = REACT_PROFILER_TYPE;\n        var StrictMode = REACT_STRICT_MODE_TYPE;\n        var Suspense = REACT_SUSPENSE_TYPE;\n        var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\n        function isAsyncMode(object) {\n          {\n            if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n              hasWarnedAboutDeprecatedIsAsyncMode = true;\n              lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n            }\n          }\n          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n        }\n\n        function isConcurrentMode(object) {\n          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n        }\n\n        function isContextConsumer(object) {\n          return typeOf(object) === REACT_CONTEXT_TYPE;\n        }\n\n        function isContextProvider(object) {\n          return typeOf(object) === REACT_PROVIDER_TYPE;\n        }\n\n        function isElement(object) {\n          return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n\n        function isForwardRef(object) {\n          return typeOf(object) === REACT_FORWARD_REF_TYPE;\n        }\n\n        function isFragment(object) {\n          return typeOf(object) === REACT_FRAGMENT_TYPE;\n        }\n\n        function isLazy(object) {\n          return typeOf(object) === REACT_LAZY_TYPE;\n        }\n\n        function isMemo(object) {\n          return typeOf(object) === REACT_MEMO_TYPE;\n        }\n\n        function isPortal(object) {\n          return typeOf(object) === REACT_PORTAL_TYPE;\n        }\n\n        function isProfiler(object) {\n          return typeOf(object) === REACT_PROFILER_TYPE;\n        }\n\n        function isStrictMode(object) {\n          return typeOf(object) === REACT_STRICT_MODE_TYPE;\n        }\n\n        function isSuspense(object) {\n          return typeOf(object) === REACT_SUSPENSE_TYPE;\n        }\n\n        exports.typeOf = typeOf;\n        exports.AsyncMode = AsyncMode;\n        exports.ConcurrentMode = ConcurrentMode;\n        exports.ContextConsumer = ContextConsumer;\n        exports.ContextProvider = ContextProvider;\n        exports.Element = Element;\n        exports.ForwardRef = ForwardRef;\n        exports.Fragment = Fragment;\n        exports.Lazy = Lazy;\n        exports.Memo = Memo;\n        exports.Portal = Portal;\n        exports.Profiler = Profiler;\n        exports.StrictMode = StrictMode;\n        exports.Suspense = Suspense;\n        exports.isValidElementType = isValidElementType;\n        exports.isAsyncMode = isAsyncMode;\n        exports.isConcurrentMode = isConcurrentMode;\n        exports.isContextConsumer = isContextConsumer;\n        exports.isContextProvider = isContextProvider;\n        exports.isElement = isElement;\n        exports.isForwardRef = isForwardRef;\n        exports.isFragment = isFragment;\n        exports.isLazy = isLazy;\n        exports.isMemo = isMemo;\n        exports.isPortal = isPortal;\n        exports.isProfiler = isProfiler;\n        exports.isStrictMode = isStrictMode;\n        exports.isSuspense = isSuspense;\n      })();\n    }\n  });\n  unwrapExports(reactIs_development);\n  var reactIs_development_1 = reactIs_development.typeOf;\n  var reactIs_development_2 = reactIs_development.AsyncMode;\n  var reactIs_development_3 = reactIs_development.ConcurrentMode;\n  var reactIs_development_4 = reactIs_development.ContextConsumer;\n  var reactIs_development_5 = reactIs_development.ContextProvider;\n  var reactIs_development_6 = reactIs_development.Element;\n  var reactIs_development_7 = reactIs_development.ForwardRef;\n  var reactIs_development_8 = reactIs_development.Fragment;\n  var reactIs_development_9 = reactIs_development.Lazy;\n  var reactIs_development_10 = reactIs_development.Memo;\n  var reactIs_development_11 = reactIs_development.Portal;\n  var reactIs_development_12 = reactIs_development.Profiler;\n  var reactIs_development_13 = reactIs_development.StrictMode;\n  var reactIs_development_14 = reactIs_development.Suspense;\n  var reactIs_development_15 = reactIs_development.isValidElementType;\n  var reactIs_development_16 = reactIs_development.isAsyncMode;\n  var reactIs_development_17 = reactIs_development.isConcurrentMode;\n  var reactIs_development_18 = reactIs_development.isContextConsumer;\n  var reactIs_development_19 = reactIs_development.isContextProvider;\n  var reactIs_development_20 = reactIs_development.isElement;\n  var reactIs_development_21 = reactIs_development.isForwardRef;\n  var reactIs_development_22 = reactIs_development.isFragment;\n  var reactIs_development_23 = reactIs_development.isLazy;\n  var reactIs_development_24 = reactIs_development.isMemo;\n  var reactIs_development_25 = reactIs_development.isPortal;\n  var reactIs_development_26 = reactIs_development.isProfiler;\n  var reactIs_development_27 = reactIs_development.isStrictMode;\n  var reactIs_development_28 = reactIs_development.isSuspense;\n  var reactIs = createCommonjsModule(function (module) {\n    {\n      module.exports = reactIs_development;\n    }\n  });\n  /**\n   * Copyright 2015, Yahoo! Inc.\n   * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n   */\n\n  var REACT_STATICS = {\n    childContextTypes: true,\n    contextType: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    getDerivedStateFromError: true,\n    getDerivedStateFromProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n  };\n  var KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    callee: true,\n    arguments: true,\n    arity: true\n  };\n  var FORWARD_REF_STATICS = {\n    '$$typeof': true,\n    render: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true\n  };\n  var MEMO_STATICS = {\n    '$$typeof': true,\n    compare: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true,\n    type: true\n  };\n  var TYPE_STATICS = {};\n  TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;\n\n  function getStatics(component) {\n    if (reactIs.isMemo(component)) {\n      return MEMO_STATICS;\n    }\n\n    return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;\n  }\n\n  var defineProperty = Object.defineProperty;\n  var getOwnPropertyNames = Object.getOwnPropertyNames;\n  var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  var getPrototypeOf = Object.getPrototypeOf;\n  var objectPrototype = Object.prototype;\n\n  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n    if (typeof sourceComponent !== 'string') {\n      // don't hoist over string (html) components\n      if (objectPrototype) {\n        var inheritedComponent = getPrototypeOf(sourceComponent);\n\n        if (inheritedComponent && inheritedComponent !== objectPrototype) {\n          hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n        }\n      }\n\n      var keys = getOwnPropertyNames(sourceComponent);\n\n      if (getOwnPropertySymbols) {\n        keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n      }\n\n      var targetStatics = getStatics(targetComponent);\n      var sourceStatics = getStatics(sourceComponent);\n\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n\n        if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n          var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n          try {\n            // Avoid failures from read-only properties\n            defineProperty(targetComponent, key, descriptor);\n          } catch (e) {}\n        }\n      }\n\n      return targetComponent;\n    }\n\n    return targetComponent;\n  }\n\n  var hoistNonReactStatics_cjs = hoistNonReactStatics;\n  var leafletContext = React.createContext({});\n\n  var useLeaflet = function useLeaflet() {\n    return React.useContext(leafletContext);\n  };\n\n  var LeafletConsumer = leafletContext.Consumer;\n  var LeafletProvider = leafletContext.Provider;\n\n  var withLeaflet = function withLeaflet(WrappedComponent) {\n    var WithLeafletComponent = function WithLeafletComponent(props, ref) {\n      return React__default.createElement(LeafletConsumer, null, function (leaflet) {\n        return React__default.createElement(WrappedComponent, _extends_1({}, props, {\n          leaflet: leaflet,\n          ref: ref\n        }));\n      });\n    };\n\n    var name = // flowlint-next-line sketchy-null-string:off\n    WrappedComponent.displayName || WrappedComponent.name || 'Component';\n    WithLeafletComponent.displayName = \"Leaflet(\".concat(name, \")\");\n    var LeafletComponent = React.forwardRef(WithLeafletComponent);\n    hoistNonReactStatics_cjs(LeafletComponent, WrappedComponent);\n    return LeafletComponent;\n  };\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var classCallCheck = _classCallCheck;\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  var createClass = _createClass;\n\n  var _typeof_1 = createCommonjsModule(function (module) {\n    function _typeof2(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof2 = function _typeof2(obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof2 = function _typeof2(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof2(obj);\n    }\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n        module.exports = _typeof = function _typeof(obj) {\n          return _typeof2(obj);\n        };\n      } else {\n        module.exports = _typeof = function _typeof(obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n        };\n      }\n\n      return _typeof(obj);\n    }\n\n    module.exports = _typeof;\n  });\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  var assertThisInitialized = _assertThisInitialized;\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (_typeof_1(call) === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n\n    return assertThisInitialized(self);\n  }\n\n  var possibleConstructorReturn = _possibleConstructorReturn;\n  var getPrototypeOf$1 = createCommonjsModule(function (module) {\n    function _getPrototypeOf(o) {\n      module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n      };\n      return _getPrototypeOf(o);\n    }\n\n    module.exports = _getPrototypeOf;\n  });\n  var setPrototypeOf = createCommonjsModule(function (module) {\n    function _setPrototypeOf(o, p) {\n      module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n      };\n\n      return _setPrototypeOf(o, p);\n    }\n\n    module.exports = _setPrototypeOf;\n  });\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) setPrototypeOf(subClass, superClass);\n  }\n\n  var inherits = _inherits;\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  var defineProperty$1 = _defineProperty;\n\n  var MapControl =\n  /*#__PURE__*/\n  function (_Component) {\n    inherits(MapControl, _Component);\n\n    function MapControl(props) {\n      var _this;\n\n      classCallCheck(this, MapControl);\n      _this = possibleConstructorReturn(this, getPrototypeOf$1(MapControl).call(this, props));\n      defineProperty$1(assertThisInitialized(_this), \"leafletElement\", void 0);\n      _this.leafletElement = _this.createLeafletElement(_this.props);\n      return _this;\n    }\n\n    createClass(MapControl, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(_props) {\n        throw new Error('createLeafletElement() must be implemented');\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        if (toProps.position !== fromProps.position) {\n          this.leafletElement.setPosition(toProps.position);\n        }\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        this.leafletElement.addTo(this.props.leaflet.map);\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        this.updateLeafletElement(prevProps, this.props);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this.leafletElement.remove();\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return null;\n      }\n    }]);\n    return MapControl;\n  }(React.Component);\n\n  var AttributionControl =\n  /*#__PURE__*/\n  function (_MapControl) {\n    inherits(AttributionControl, _MapControl);\n\n    function AttributionControl() {\n      classCallCheck(this, AttributionControl);\n      return possibleConstructorReturn(this, getPrototypeOf$1(AttributionControl).apply(this, arguments));\n    }\n\n    createClass(AttributionControl, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        return new leaflet.Control.Attribution(props);\n      }\n    }]);\n    return AttributionControl;\n  }(MapControl);\n\n  var AttributionControl$1 = withLeaflet(AttributionControl);\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;\n\n  function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n  var objectWithoutProperties = _objectWithoutProperties;\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n\n      ownKeys.forEach(function (key) {\n        defineProperty$1(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  var objectSpread = _objectSpread;\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = getPrototypeOf$1(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  var superPropBase = _superPropBase;\n  var get = createCommonjsModule(function (module) {\n    function _get(target, property, receiver) {\n      if (typeof Reflect !== \"undefined\" && Reflect.get) {\n        module.exports = _get = Reflect.get;\n      } else {\n        module.exports = _get = function _get(target, property, receiver) {\n          var base = superPropBase(target, property);\n          if (!base) return;\n          var desc = Object.getOwnPropertyDescriptor(base, property);\n\n          if (desc.get) {\n            return desc.get.call(receiver);\n          }\n\n          return desc.value;\n        };\n      }\n\n      return _get(target, property, receiver || target);\n    }\n\n    module.exports = _get;\n  });\n  var isArray = Array.isArray;\n  var keyList = Object.keys;\n  var hasProp = Object.prototype.hasOwnProperty;\n\n  var fastDeepEqual = function equal(a, b) {\n    if (a === b) return true;\n\n    if (a && b && typeof a == 'object' && typeof b == 'object') {\n      var arrA = isArray(a),\n          arrB = isArray(b),\n          i,\n          length,\n          key;\n\n      if (arrA && arrB) {\n        length = a.length;\n        if (length != b.length) return false;\n\n        for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;\n\n        return true;\n      }\n\n      if (arrA != arrB) return false;\n      var dateA = a instanceof Date,\n          dateB = b instanceof Date;\n      if (dateA != dateB) return false;\n      if (dateA && dateB) return a.getTime() == b.getTime();\n      var regexpA = a instanceof RegExp,\n          regexpB = b instanceof RegExp;\n      if (regexpA != regexpB) return false;\n      if (regexpA && regexpB) return a.toString() == b.toString();\n      var keys = keyList(a);\n      length = keys.length;\n      if (length !== keyList(b).length) return false;\n\n      for (i = length; i-- !== 0;) if (!hasProp.call(b, keys[i])) return false;\n\n      for (i = length; i-- !== 0;) {\n        key = keys[i];\n        if (!equal(a[key], b[key])) return false;\n      }\n\n      return true;\n    }\n\n    return a !== a && b !== b;\n  };\n\n  var EVENTS_RE = /^on(.+)$/i;\n\n  var MapEvented =\n  /*#__PURE__*/\n  function (_Component) {\n    inherits(MapEvented, _Component);\n\n    function MapEvented(props) {\n      var _this;\n\n      classCallCheck(this, MapEvented);\n      _this = possibleConstructorReturn(this, getPrototypeOf$1(MapEvented).call(this, props));\n      defineProperty$1(assertThisInitialized(_this), \"_leafletEvents\", void 0);\n      defineProperty$1(assertThisInitialized(_this), \"leafletElement\", void 0);\n      _this._leafletEvents = _this.extractLeafletEvents(props);\n      return _this;\n    }\n\n    createClass(MapEvented, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        this.bindLeafletEvents(this._leafletEvents);\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(_prevProps) {\n        this._leafletEvents = this.bindLeafletEvents(this.extractLeafletEvents(this.props), this._leafletEvents);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        var _this2 = this;\n\n        var el = this.leafletElement;\n        if (!el) return;\n        Object.keys(this._leafletEvents).forEach(function (ev) {\n          el.off(ev, _this2._leafletEvents[ev]);\n        });\n      }\n    }, {\n      key: \"extractLeafletEvents\",\n      value: function extractLeafletEvents(props) {\n        return Object.keys(props).reduce(function (res, prop) {\n          if (EVENTS_RE.test(prop)) {\n            if (props[prop] != null) {\n              var _key = prop.replace(EVENTS_RE, function (match, p) {\n                return p.toLowerCase();\n              });\n\n              res[_key] = props[prop];\n            }\n          }\n\n          return res;\n        }, {});\n      }\n    }, {\n      key: \"bindLeafletEvents\",\n      value: function bindLeafletEvents() {\n        var next = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var el = this.leafletElement;\n        if (el == null || el.on == null) return {};\n        var diff = objectSpread({}, prev);\n        Object.keys(prev).forEach(function (ev) {\n          if (next[ev] == null || prev[ev] !== next[ev]) {\n            delete diff[ev];\n            el.off(ev, prev[ev]);\n          }\n        });\n        Object.keys(next).forEach(function (ev) {\n          if (prev[ev] == null || next[ev] !== prev[ev]) {\n            diff[ev] = next[ev];\n            el.on(ev, next[ev]);\n          }\n        });\n        return diff;\n      }\n    }, {\n      key: \"fireLeafletEvent\",\n      value: function fireLeafletEvent(type, data) {\n        var el = this.leafletElement;\n        if (el) el.fire(type, data);\n      }\n    }]);\n    return MapEvented;\n  }(React.Component);\n\n  var MapComponent =\n  /*#__PURE__*/\n  function (_MapEvented) {\n    inherits(MapComponent, _MapEvented);\n\n    function MapComponent() {\n      classCallCheck(this, MapComponent);\n      return possibleConstructorReturn(this, getPrototypeOf$1(MapComponent).apply(this, arguments));\n    }\n\n    createClass(MapComponent, [{\n      key: \"getOptions\",\n      value: function getOptions(props) {\n        if (props.pane != null) {\n          return props;\n        }\n\n        if (props.leaflet != null && props.leaflet.pane != null) {\n          return objectSpread({}, props, {\n            pane: props.leaflet.pane\n          });\n        }\n\n        return props;\n      }\n    }]);\n    return MapComponent;\n  }(MapEvented);\n\n  var MapLayer =\n  /*#__PURE__*/\n  function (_MapComponent) {\n    inherits(MapLayer, _MapComponent);\n\n    function MapLayer(props) {\n      var _this;\n\n      classCallCheck(this, MapLayer);\n      _this = possibleConstructorReturn(this, getPrototypeOf$1(MapLayer).call(this, props));\n      defineProperty$1(assertThisInitialized(_this), \"contextValue\", void 0);\n      defineProperty$1(assertThisInitialized(_this), \"leafletElement\", void 0);\n      _this.leafletElement = _this.createLeafletElement(props);\n      return _this;\n    }\n\n    createClass(MapLayer, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(_props) {\n        throw new Error('createLeafletElement() must be implemented');\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(_fromProps, _toProps) {}\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        get(getPrototypeOf$1(MapLayer.prototype), \"componentDidMount\", this).call(this);\n        this.layerContainer.addLayer(this.leafletElement);\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        get(getPrototypeOf$1(MapLayer.prototype), \"componentDidUpdate\", this).call(this, prevProps);\n\n        if (this.props.attribution !== prevProps.attribution) {\n          var map = this.props.leaflet.map;\n\n          if (map != null && map.attributionControl != null) {\n            map.attributionControl.removeAttribution(prevProps.attribution);\n            map.attributionControl.addAttribution(this.props.attribution);\n          }\n        }\n\n        this.updateLeafletElement(prevProps, this.props);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        get(getPrototypeOf$1(MapLayer.prototype), \"componentWillUnmount\", this).call(this);\n        this.layerContainer.removeLayer(this.leafletElement);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var children = this.props.children;\n\n        if (children == null) {\n          return null;\n        }\n\n        return this.contextValue == null ? React__default.createElement(React.Fragment, null, children) : React__default.createElement(LeafletProvider, {\n          value: this.contextValue\n        }, children);\n      }\n    }, {\n      key: \"layerContainer\",\n      get: function get() {\n        return this.props.leaflet.layerContainer || this.props.leaflet.map;\n      }\n    }]);\n    return MapLayer;\n  }(MapComponent);\n\n  function pick(object, keys) {\n    return keys.reduce(function (obj, key) {\n      if (object[key]) {\n        obj[key] = object[key];\n      }\n\n      return obj;\n    }, {});\n  }\n\n  var OPTIONS = ['stroke', 'color', 'weight', 'opacity', 'lineCap', 'lineJoin', 'dashArray', 'dashOffset', 'fill', 'fillColor', 'fillOpacity', 'fillRule', 'bubblingMouseEvents', 'renderer', 'className', // Interactive Layer\n  'interactive', // Layer\n  'pane', 'attribution'];\n\n  var Path =\n  /*#__PURE__*/\n  function (_MapLayer) {\n    inherits(Path, _MapLayer);\n\n    function Path(props) {\n      var _this;\n\n      classCallCheck(this, Path);\n      _this = possibleConstructorReturn(this, getPrototypeOf$1(Path).call(this, props));\n\n      if (_this.contextValue == null) {\n        _this.contextValue = objectSpread({}, props.leaflet, {\n          popupContainer: _this.leafletElement\n        });\n      }\n\n      return _this;\n    }\n\n    createClass(Path, [{\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        get(getPrototypeOf$1(Path.prototype), \"componentDidUpdate\", this).call(this, prevProps);\n        this.setStyleIfChanged(prevProps, this.props);\n      }\n    }, {\n      key: \"getPathOptions\",\n      value: function getPathOptions(props) {\n        return pick(props, OPTIONS);\n      }\n    }, {\n      key: \"setStyle\",\n      value: function setStyle() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.leafletElement.setStyle(options);\n      }\n    }, {\n      key: \"setStyleIfChanged\",\n      value: function setStyleIfChanged(fromProps, toProps) {\n        var nextStyle = this.getPathOptions(toProps);\n\n        if (!fastDeepEqual(nextStyle, this.getPathOptions(fromProps))) {\n          this.setStyle(nextStyle);\n        }\n      }\n    }]);\n    return Path;\n  }(MapLayer);\n\n  var Circle =\n  /*#__PURE__*/\n  function (_Path) {\n    inherits(Circle, _Path);\n\n    function Circle() {\n      classCallCheck(this, Circle);\n      return possibleConstructorReturn(this, getPrototypeOf$1(Circle).apply(this, arguments));\n    }\n\n    createClass(Circle, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        var center = props.center,\n            radius = props.radius,\n            options = objectWithoutProperties(props, [\"center\", \"radius\"]);\n        return new leaflet.Circle(center, radius, this.getOptions(options));\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        if (toProps.center !== fromProps.center) {\n          this.leafletElement.setLatLng(toProps.center);\n        }\n\n        if (toProps.radius !== fromProps.radius) {\n          this.leafletElement.setRadius(toProps.radius);\n        }\n      }\n    }]);\n    return Circle;\n  }(Path);\n\n  var Circle$1 = withLeaflet(Circle);\n\n  var CircleMarker =\n  /*#__PURE__*/\n  function (_Path) {\n    inherits(CircleMarker, _Path);\n\n    function CircleMarker() {\n      classCallCheck(this, CircleMarker);\n      return possibleConstructorReturn(this, getPrototypeOf$1(CircleMarker).apply(this, arguments));\n    }\n\n    createClass(CircleMarker, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        var el = new leaflet.CircleMarker(props.center, this.getOptions(props));\n        this.contextValue = objectSpread({}, props.leaflet, {\n          popupContainer: el\n        });\n        return el;\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        if (toProps.center !== fromProps.center) {\n          this.leafletElement.setLatLng(toProps.center);\n        }\n\n        if (toProps.radius !== fromProps.radius) {\n          this.leafletElement.setRadius(toProps.radius);\n        }\n      }\n    }]);\n    return CircleMarker;\n  }(Path);\n\n  var CircleMarker$1 = withLeaflet(CircleMarker);\n\n  var splitClassName = function splitClassName() {\n    var className = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return className.split(' ').filter(Boolean);\n  };\n\n  var addClassName = function addClassName(container, className) {\n    splitClassName(className).forEach(function (cls) {\n      leaflet.DomUtil.addClass(container, cls);\n    });\n  };\n\n  var removeClassName = function removeClassName(container, className) {\n    splitClassName(className).forEach(function (cls) {\n      leaflet.DomUtil.removeClass(container, cls);\n    });\n  };\n\n  var updateClassName = function (container, prevClassName, nextClassName) {\n    if (container != null && nextClassName !== prevClassName) {\n      if (prevClassName != null && prevClassName.length > 0) {\n        removeClassName(container, prevClassName);\n      }\n\n      if (nextClassName != null && nextClassName.length > 0) {\n        addClassName(container, nextClassName);\n      }\n    }\n  };\n\n  var DivOverlay =\n  /*#__PURE__*/\n  function (_MapComponent) {\n    inherits(DivOverlay, _MapComponent);\n\n    function DivOverlay(props) {\n      var _this;\n\n      classCallCheck(this, DivOverlay);\n      _this = possibleConstructorReturn(this, getPrototypeOf$1(DivOverlay).call(this, props));\n      defineProperty$1(assertThisInitialized(_this), \"onClose\", function () {\n        if (_this.props.onClose) {\n          _this.props.onClose();\n        }\n      });\n      defineProperty$1(assertThisInitialized(_this), \"onOpen\", function () {\n        _this.forceUpdate(); // Re-render now that leafletElement is created\n\n\n        if (_this.props.onOpen) {\n          _this.props.onOpen();\n        }\n      });\n      _this.leafletElement = _this.createLeafletElement(props);\n      return _this;\n    }\n\n    createClass(DivOverlay, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(_props) {\n        throw new Error('createLeafletElement() must be implemented');\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(_prevProps, _props) {}\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        updateClassName(this.leafletElement._container, prevProps.className, this.props.className);\n        this.updateLeafletElement(prevProps, this.props);\n\n        if (this.leafletElement.isOpen()) {\n          this.leafletElement.update();\n          this.onRender();\n        }\n      }\n    }, {\n      key: \"onRender\",\n      value: function onRender() {}\n    }, {\n      key: \"render\",\n      value: function render() {\n        if (this.leafletElement._contentNode) {\n          return reactDom.createPortal(this.props.children, this.leafletElement._contentNode);\n        }\n\n        return null;\n      }\n    }]);\n    return DivOverlay;\n  }(MapComponent);\n\n  var FeatureGroup =\n  /*#__PURE__*/\n  function (_Path) {\n    inherits(FeatureGroup, _Path);\n\n    function FeatureGroup() {\n      classCallCheck(this, FeatureGroup);\n      return possibleConstructorReturn(this, getPrototypeOf$1(FeatureGroup).apply(this, arguments));\n    }\n\n    createClass(FeatureGroup, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        var el = new leaflet.FeatureGroup(this.getOptions(props));\n        this.contextValue = objectSpread({}, props.leaflet, {\n          layerContainer: el,\n          popupContainer: el\n        });\n        return el;\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        get(getPrototypeOf$1(FeatureGroup.prototype), \"componentDidMount\", this).call(this);\n        this.setStyle(this.props);\n      }\n    }]);\n    return FeatureGroup;\n  }(Path);\n\n  var FeatureGroup$1 = withLeaflet(FeatureGroup);\n\n  var GeoJSON =\n  /*#__PURE__*/\n  function (_Path) {\n    inherits(GeoJSON, _Path);\n\n    function GeoJSON() {\n      classCallCheck(this, GeoJSON);\n      return possibleConstructorReturn(this, getPrototypeOf$1(GeoJSON).apply(this, arguments));\n    }\n\n    createClass(GeoJSON, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        return new leaflet.GeoJSON(props.data, this.getOptions(props));\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        if (typeof toProps.style === 'function') {\n          this.setStyle(toProps.style);\n        } else {\n          this.setStyleIfChanged(fromProps, toProps);\n        }\n      }\n    }]);\n    return GeoJSON;\n  }(Path);\n\n  var GeoJSON$1 = withLeaflet(GeoJSON);\n\n  var GridLayer =\n  /*#__PURE__*/\n  function (_MapLayer) {\n    inherits(GridLayer, _MapLayer);\n\n    function GridLayer() {\n      classCallCheck(this, GridLayer);\n      return possibleConstructorReturn(this, getPrototypeOf$1(GridLayer).apply(this, arguments));\n    }\n\n    createClass(GridLayer, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        return new leaflet.GridLayer(this.getOptions(props));\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        var opacity = toProps.opacity,\n            zIndex = toProps.zIndex;\n\n        if (opacity !== fromProps.opacity) {\n          this.leafletElement.setOpacity(opacity);\n        }\n\n        if (zIndex !== fromProps.zIndex) {\n          this.leafletElement.setZIndex(zIndex);\n        }\n      }\n    }, {\n      key: \"getOptions\",\n      value: function getOptions(props) {\n        var options = get(getPrototypeOf$1(GridLayer.prototype), \"getOptions\", this).call(this, props);\n        return props.leaflet.map == null ? options : // $FlowFixMe: object spread type\n        objectSpread({\n          maxZoom: props.leaflet.map.options.maxZoom,\n          minZoom: props.leaflet.map.options.minZoom\n        }, options);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return null;\n      }\n    }]);\n    return GridLayer;\n  }(MapLayer);\n\n  var ImageOverlay =\n  /*#__PURE__*/\n  function (_MapLayer) {\n    inherits(ImageOverlay, _MapLayer);\n\n    function ImageOverlay() {\n      classCallCheck(this, ImageOverlay);\n      return possibleConstructorReturn(this, getPrototypeOf$1(ImageOverlay).apply(this, arguments));\n    }\n\n    createClass(ImageOverlay, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        var el = new leaflet.ImageOverlay(props.url, props.bounds, this.getOptions(props));\n        this.contextValue = objectSpread({}, props.leaflet, {\n          popupContainer: el\n        });\n        return el;\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        if (toProps.url !== fromProps.url) {\n          this.leafletElement.setUrl(toProps.url);\n        }\n\n        if (toProps.bounds !== fromProps.bounds) {\n          this.leafletElement.setBounds(leaflet.latLngBounds(toProps.bounds));\n        }\n\n        if (toProps.opacity !== fromProps.opacity) {\n          this.leafletElement.setOpacity(toProps.opacity);\n        }\n\n        if (toProps.zIndex !== fromProps.zIndex) {\n          this.leafletElement.setZIndex(toProps.zIndex);\n        }\n      }\n    }]);\n    return ImageOverlay;\n  }(MapLayer);\n\n  var ImageOverlay$1 = withLeaflet(ImageOverlay);\n\n  var LayerGroup =\n  /*#__PURE__*/\n  function (_MapLayer) {\n    inherits(LayerGroup, _MapLayer);\n\n    function LayerGroup() {\n      classCallCheck(this, LayerGroup);\n      return possibleConstructorReturn(this, getPrototypeOf$1(LayerGroup).apply(this, arguments));\n    }\n\n    createClass(LayerGroup, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        var el = new leaflet.LayerGroup([], this.getOptions(props));\n        this.contextValue = objectSpread({}, props.leaflet, {\n          layerContainer: el\n        });\n        return el;\n      }\n    }]);\n    return LayerGroup;\n  }(MapLayer);\n\n  var LayerGroup$1 = withLeaflet(LayerGroup); // Abtract class for layer container, extended by BaseLayer and Overlay\n\n  var ControlledLayer =\n  /*#__PURE__*/\n  function (_Component) {\n    inherits(ControlledLayer, _Component);\n\n    function ControlledLayer() {\n      var _getPrototypeOf2;\n\n      var _this;\n\n      classCallCheck(this, ControlledLayer);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = possibleConstructorReturn(this, (_getPrototypeOf2 = getPrototypeOf$1(ControlledLayer)).call.apply(_getPrototypeOf2, [this].concat(args)));\n      defineProperty$1(assertThisInitialized(_this), \"contextValue\", void 0);\n      defineProperty$1(assertThisInitialized(_this), \"layer\", void 0);\n      return _this;\n    }\n\n    createClass(ControlledLayer, [{\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(_ref) {\n        var checked = _ref.checked;\n\n        if (this.props.leaflet.map == null) {\n          return;\n        } // Handle dynamically (un)checking the layer => adding/removing from the map\n\n\n        if (this.props.checked === true && (checked == null || checked === false)) {\n          this.props.leaflet.map.addLayer(this.layer);\n        } else if (checked === true && (this.props.checked == null || this.props.checked === false)) {\n          this.props.leaflet.map.removeLayer(this.layer);\n        }\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this.props.removeLayerControl(this.layer);\n      }\n    }, {\n      key: \"addLayer\",\n      value: function addLayer() {\n        throw new Error('Must be implemented in extending class');\n      }\n    }, {\n      key: \"removeLayer\",\n      value: function removeLayer(layer) {\n        this.props.removeLayer(layer);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var children = this.props.children;\n        return children ? React__default.createElement(LeafletProvider, {\n          value: this.contextValue\n        }, children) : null;\n      }\n    }]);\n    return ControlledLayer;\n  }(React.Component);\n\n  var BaseLayer =\n  /*#__PURE__*/\n  function (_ControlledLayer) {\n    inherits(BaseLayer, _ControlledLayer);\n\n    function BaseLayer(props) {\n      var _this2;\n\n      classCallCheck(this, BaseLayer);\n      _this2 = possibleConstructorReturn(this, getPrototypeOf$1(BaseLayer).call(this, props));\n      defineProperty$1(assertThisInitialized(_this2), \"addLayer\", function (layer) {\n        _this2.layer = layer; // Keep layer reference to handle dynamic changes of props\n\n        var _this2$props = _this2.props,\n            addBaseLayer = _this2$props.addBaseLayer,\n            checked = _this2$props.checked,\n            name = _this2$props.name;\n        addBaseLayer(layer, name, checked);\n      });\n      _this2.contextValue = objectSpread({}, props.leaflet, {\n        layerContainer: {\n          addLayer: _this2.addLayer.bind(assertThisInitialized(_this2)),\n          removeLayer: _this2.removeLayer.bind(assertThisInitialized(_this2))\n        }\n      });\n      return _this2;\n    }\n\n    return BaseLayer;\n  }(ControlledLayer);\n\n  var Overlay =\n  /*#__PURE__*/\n  function (_ControlledLayer2) {\n    inherits(Overlay, _ControlledLayer2);\n\n    function Overlay(props) {\n      var _this3;\n\n      classCallCheck(this, Overlay);\n      _this3 = possibleConstructorReturn(this, getPrototypeOf$1(Overlay).call(this, props));\n      defineProperty$1(assertThisInitialized(_this3), \"addLayer\", function (layer) {\n        _this3.layer = layer; // Keep layer reference to handle dynamic changes of props\n\n        var _this3$props = _this3.props,\n            addOverlay = _this3$props.addOverlay,\n            checked = _this3$props.checked,\n            name = _this3$props.name;\n        addOverlay(layer, name, checked);\n      });\n      _this3.contextValue = objectSpread({}, props.leaflet, {\n        layerContainer: {\n          addLayer: _this3.addLayer.bind(assertThisInitialized(_this3)),\n          removeLayer: _this3.removeLayer.bind(assertThisInitialized(_this3))\n        }\n      });\n      return _this3;\n    }\n\n    return Overlay;\n  }(ControlledLayer);\n\n  var LayersControl =\n  /*#__PURE__*/\n  function (_MapControl) {\n    inherits(LayersControl, _MapControl);\n\n    function LayersControl(props) {\n      var _this4;\n\n      classCallCheck(this, LayersControl);\n      _this4 = possibleConstructorReturn(this, getPrototypeOf$1(LayersControl).call(this, props));\n      defineProperty$1(assertThisInitialized(_this4), \"controlProps\", void 0);\n      _this4.controlProps = {\n        addBaseLayer: _this4.addBaseLayer.bind(assertThisInitialized(_this4)),\n        addOverlay: _this4.addOverlay.bind(assertThisInitialized(_this4)),\n        leaflet: props.leaflet,\n        removeLayer: _this4.removeLayer.bind(assertThisInitialized(_this4)),\n        removeLayerControl: _this4.removeLayerControl.bind(assertThisInitialized(_this4))\n      };\n      return _this4;\n    }\n\n    createClass(LayersControl, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        var _children = props.children,\n            options = objectWithoutProperties(props, [\"children\"]);\n        return new leaflet.Control.Layers(undefined, undefined, options);\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        get(getPrototypeOf$1(LayersControl.prototype), \"updateLeafletElement\", this).call(this, fromProps, toProps);\n\n        if (toProps.collapsed !== fromProps.collapsed) {\n          if (toProps.collapsed === true) {\n            this.leafletElement.collapse();\n          } else {\n            this.leafletElement.expand();\n          }\n        }\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        var _this5 = this;\n\n        setTimeout(function () {\n          get(getPrototypeOf$1(LayersControl.prototype), \"componentWillUnmount\", _this5).call(_this5);\n        }, 0);\n      }\n    }, {\n      key: \"addBaseLayer\",\n      value: function addBaseLayer(layer, name) {\n        var checked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        if (checked && this.props.leaflet.map != null) {\n          this.props.leaflet.map.addLayer(layer);\n        }\n\n        this.leafletElement.addBaseLayer(layer, name);\n      }\n    }, {\n      key: \"addOverlay\",\n      value: function addOverlay(layer, name) {\n        var checked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        if (checked && this.props.leaflet.map != null) {\n          this.props.leaflet.map.addLayer(layer);\n        }\n\n        this.leafletElement.addOverlay(layer, name);\n      }\n    }, {\n      key: \"removeLayer\",\n      value: function removeLayer(layer) {\n        if (this.props.leaflet.map != null) {\n          this.props.leaflet.map.removeLayer(layer);\n        }\n      }\n    }, {\n      key: \"removeLayerControl\",\n      value: function removeLayerControl(layer) {\n        this.leafletElement.removeLayer(layer);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this6 = this;\n\n        var children = React.Children.map(this.props.children, function (child) {\n          return child ? React.cloneElement(child, _this6.controlProps) : null;\n        });\n        return React__default.createElement(React.Fragment, null, children);\n      }\n    }]);\n    return LayersControl;\n  }(MapControl);\n\n  var LayersControlExport = withLeaflet(LayersControl);\n  LayersControlExport.BaseLayer = BaseLayer;\n  LayersControlExport.Overlay = Overlay;\n\n  function omit(obj) {\n    for (var _len = arguments.length, keysToOmit = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      keysToOmit[_key - 1] = arguments[_key];\n    }\n\n    return Object.keys(obj).reduce(function (acc, key) {\n      if (keysToOmit.indexOf(key) === -1) {\n        acc[key] = obj[key];\n      }\n\n      return acc;\n    }, {});\n  }\n\n  var OTHER_PROPS = ['children', 'className', 'id', 'style', 'useFlyTo', 'whenReady'];\n\n  var normalizeCenter = function normalizeCenter(pos) {\n    return Array.isArray(pos) ? [pos[0], pos[1]] : [pos.lat, pos.lon ? pos.lon : pos.lng];\n  };\n\n  var Map =\n  /*#__PURE__*/\n  function (_MapEvented) {\n    inherits(Map, _MapEvented);\n\n    function Map(props) {\n      var _this;\n\n      classCallCheck(this, Map);\n      _this = possibleConstructorReturn(this, getPrototypeOf$1(Map).call(this, props));\n      defineProperty$1(assertThisInitialized(_this), \"className\", void 0);\n      defineProperty$1(assertThisInitialized(_this), \"contextValue\", void 0);\n      defineProperty$1(assertThisInitialized(_this), \"container\", void 0);\n      defineProperty$1(assertThisInitialized(_this), \"viewport\", {\n        center: undefined,\n        zoom: undefined\n      });\n      defineProperty$1(assertThisInitialized(_this), \"_ready\", false);\n      defineProperty$1(assertThisInitialized(_this), \"_updating\", false);\n      defineProperty$1(assertThisInitialized(_this), \"onViewportChange\", function () {\n        var center = _this.leafletElement.getCenter();\n\n        _this.viewport = {\n          center: center ? [center.lat, center.lng] : undefined,\n          zoom: _this.leafletElement.getZoom()\n        };\n\n        if (_this.props.onViewportChange && !_this._updating) {\n          _this.props.onViewportChange(_this.viewport);\n        }\n      });\n      defineProperty$1(assertThisInitialized(_this), \"onViewportChanged\", function () {\n        if (_this.props.onViewportChanged && !_this._updating) {\n          _this.props.onViewportChanged(_this.viewport);\n        }\n      });\n      defineProperty$1(assertThisInitialized(_this), \"bindContainer\", function (container) {\n        _this.container = container;\n      });\n      _this.className = props.className;\n      return _this;\n    }\n\n    createClass(Map, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        var viewport = props.viewport,\n            options = objectWithoutProperties(props, [\"viewport\"]);\n\n        if (viewport) {\n          if (viewport.center) {\n            options.center = viewport.center;\n          }\n\n          if (typeof viewport.zoom === 'number') {\n            options.zoom = viewport.zoom;\n          }\n        }\n\n        return new leaflet.Map(this.container, options);\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        this._updating = true;\n        var animate = toProps.animate,\n            bounds = toProps.bounds,\n            boundsOptions = toProps.boundsOptions,\n            boxZoom = toProps.boxZoom,\n            center = toProps.center,\n            className = toProps.className,\n            doubleClickZoom = toProps.doubleClickZoom,\n            dragging = toProps.dragging,\n            keyboard = toProps.keyboard,\n            maxBounds = toProps.maxBounds,\n            scrollWheelZoom = toProps.scrollWheelZoom,\n            tap = toProps.tap,\n            touchZoom = toProps.touchZoom,\n            useFlyTo = toProps.useFlyTo,\n            viewport = toProps.viewport,\n            zoom = toProps.zoom;\n        updateClassName(this.container, fromProps.className, className);\n\n        if (viewport && viewport !== fromProps.viewport) {\n          var c = viewport.center ? viewport.center : center;\n          var z = viewport.zoom == null ? zoom : viewport.zoom;\n\n          if (useFlyTo === true) {\n            this.leafletElement.flyTo(c, z, {\n              animate: animate\n            });\n          } else {\n            this.leafletElement.setView(c, z, {\n              animate: animate\n            });\n          }\n        } else if (center && this.shouldUpdateCenter(center, fromProps.center)) {\n          if (useFlyTo === true) {\n            this.leafletElement.flyTo(center, zoom, {\n              animate: animate\n            });\n          } else {\n            this.leafletElement.setView(center, zoom, {\n              animate: animate\n            });\n          }\n        } else if (typeof zoom === 'number' && zoom !== fromProps.zoom) {\n          if (fromProps.zoom == null) {\n            this.leafletElement.setView(center, zoom);\n          } else {\n            this.leafletElement.setZoom(zoom);\n          }\n        }\n\n        if (maxBounds && this.shouldUpdateBounds(maxBounds, fromProps.maxBounds)) {\n          this.leafletElement.setMaxBounds(maxBounds);\n        }\n\n        if (bounds && (this.shouldUpdateBounds(bounds, fromProps.bounds) || boundsOptions !== fromProps.boundsOptions)) {\n          if (useFlyTo === true) {\n            this.leafletElement.flyToBounds(bounds, boundsOptions);\n          } else {\n            this.leafletElement.fitBounds(bounds, boundsOptions);\n          }\n        }\n\n        if (boxZoom !== fromProps.boxZoom) {\n          if (boxZoom === true) {\n            this.leafletElement.boxZoom.enable();\n          } else {\n            this.leafletElement.boxZoom.disable();\n          }\n        }\n\n        if (doubleClickZoom !== fromProps.doubleClickZoom) {\n          if (doubleClickZoom === true) {\n            this.leafletElement.doubleClickZoom.enable();\n          } else {\n            this.leafletElement.doubleClickZoom.disable();\n          }\n        }\n\n        if (dragging !== fromProps.dragging) {\n          if (dragging === true) {\n            this.leafletElement.dragging.enable();\n          } else {\n            this.leafletElement.dragging.disable();\n          }\n        }\n\n        if (keyboard !== fromProps.keyboard) {\n          if (keyboard === true) {\n            this.leafletElement.keyboard.enable();\n          } else {\n            this.leafletElement.keyboard.disable();\n          }\n        }\n\n        if (scrollWheelZoom !== fromProps.scrollWheelZoom) {\n          if (scrollWheelZoom === true || typeof scrollWheelZoom === 'string') {\n            this.leafletElement.options.scrollWheelZoom = scrollWheelZoom;\n            this.leafletElement.scrollWheelZoom.enable();\n          } else {\n            this.leafletElement.scrollWheelZoom.disable();\n          }\n        }\n\n        if (tap !== fromProps.tap) {\n          if (tap === true) {\n            this.leafletElement.tap.enable();\n          } else {\n            this.leafletElement.tap.disable();\n          }\n        }\n\n        if (touchZoom !== fromProps.touchZoom) {\n          if (touchZoom === true || typeof touchZoom === 'string') {\n            this.leafletElement.options.touchZoom = touchZoom;\n            this.leafletElement.touchZoom.enable();\n          } else {\n            this.leafletElement.touchZoom.disable();\n          }\n        }\n\n        this._updating = false;\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var props = omit.apply(void 0, [this.props].concat(OTHER_PROPS));\n        this.leafletElement = this.createLeafletElement(props);\n        this.leafletElement.on('move', this.onViewportChange);\n        this.leafletElement.on('moveend', this.onViewportChanged);\n\n        if (props.bounds != null) {\n          this.leafletElement.fitBounds(props.bounds, props.boundsOptions);\n        }\n\n        this.contextValue = {\n          layerContainer: this.leafletElement,\n          map: this.leafletElement\n        };\n        get(getPrototypeOf$1(Map.prototype), \"componentDidMount\", this).call(this);\n        this.forceUpdate(); // Re-render now that leafletElement is created\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        if (this._ready === false) {\n          this._ready = true;\n\n          if (this.props.whenReady) {\n            this.leafletElement.whenReady(this.props.whenReady);\n          }\n        }\n\n        get(getPrototypeOf$1(Map.prototype), \"componentDidUpdate\", this).call(this, prevProps);\n        this.updateLeafletElement(prevProps, this.props);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        get(getPrototypeOf$1(Map.prototype), \"componentWillUnmount\", this).call(this);\n        this.leafletElement.off('move', this.onViewportChange);\n        this.leafletElement.off('moveend', this.onViewportChanged); // The canvas renderer uses requestAnimationFrame, making a deferred call to a deleted object\n        // When preferCanvas is set, use simpler teardown logic\n\n        if (this.props.preferCanvas === true) {\n          this.leafletElement._initEvents(true);\n\n          this.leafletElement._stop();\n        } else {\n          this.leafletElement.remove();\n        }\n      }\n    }, {\n      key: \"shouldUpdateCenter\",\n      value: function shouldUpdateCenter(next, prev) {\n        if (!prev) return true;\n        next = normalizeCenter(next);\n        prev = normalizeCenter(prev);\n        return next[0] !== prev[0] || next[1] !== prev[1];\n      }\n    }, {\n      key: \"shouldUpdateBounds\",\n      value: function shouldUpdateBounds(next, prev) {\n        return prev ? !leaflet.latLngBounds(next).equals(leaflet.latLngBounds(prev)) : true;\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return React__default.createElement(\"div\", {\n          className: this.className,\n          id: this.props.id,\n          ref: this.bindContainer,\n          style: this.props.style\n        }, this.contextValue ? React__default.createElement(LeafletProvider, {\n          value: this.contextValue\n        }, this.props.children) : null);\n      }\n    }]);\n    return Map;\n  }(MapEvented);\n\n  var Marker =\n  /*#__PURE__*/\n  function (_MapLayer) {\n    inherits(Marker, _MapLayer);\n\n    function Marker() {\n      classCallCheck(this, Marker);\n      return possibleConstructorReturn(this, getPrototypeOf$1(Marker).apply(this, arguments));\n    }\n\n    createClass(Marker, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        var el = new leaflet.Marker(props.position, this.getOptions(props));\n        this.contextValue = objectSpread({}, props.leaflet, {\n          popupContainer: el\n        });\n        return el;\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        if (toProps.position !== fromProps.position) {\n          this.leafletElement.setLatLng(toProps.position);\n        }\n\n        if (toProps.icon !== fromProps.icon) {\n          this.leafletElement.setIcon(toProps.icon);\n        }\n\n        if (toProps.zIndexOffset !== fromProps.zIndexOffset) {\n          this.leafletElement.setZIndexOffset(toProps.zIndexOffset);\n        }\n\n        if (toProps.opacity !== fromProps.opacity) {\n          this.leafletElement.setOpacity(toProps.opacity);\n        }\n\n        if (toProps.draggable !== fromProps.draggable) {\n          if (toProps.draggable === true) {\n            this.leafletElement.dragging.enable();\n          } else {\n            this.leafletElement.dragging.disable();\n          }\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var children = this.props.children;\n        return children == null || this.contextValue == null ? null : React__default.createElement(LeafletProvider, {\n          value: this.contextValue\n        }, children);\n      }\n    }]);\n    return Marker;\n  }(MapLayer);\n\n  var Marker$1 = withLeaflet(Marker);\n  /**\n   * Copyright (c) 2014-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  var warning = function () {};\n\n  {\n    var printWarning = function printWarning(format, args) {\n      var len = arguments.length;\n      args = new Array(len > 1 ? len - 1 : 0);\n\n      for (var key = 1; key < len; key++) {\n        args[key - 1] = arguments[key];\n      }\n\n      var argIndex = 0;\n      var message = 'Warning: ' + format.replace(/%s/g, function () {\n        return args[argIndex++];\n      });\n\n      if (typeof console !== 'undefined') {\n        console.error(message);\n      }\n\n      try {\n        // --- Welcome to debugging React ---\n        // This error was thrown as a convenience so that you can use this stack\n        // to find the callsite that caused this warning to fire.\n        throw new Error(message);\n      } catch (x) {}\n    };\n\n    warning = function (condition, format, args) {\n      var len = arguments.length;\n      args = new Array(len > 2 ? len - 2 : 0);\n\n      for (var key = 2; key < len; key++) {\n        args[key - 2] = arguments[key];\n      }\n\n      if (format === undefined) {\n        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n      }\n\n      if (!condition) {\n        printWarning.apply(null, [format].concat(args));\n      }\n    };\n  }\n  var warning_1 = warning;\n  var idCounter = 0;\n\n  var uniqueId = function uniqueId() {\n    return ++idCounter;\n  };\n\n  var LEAFLET_PANES = ['tile', 'shadow', 'overlay', 'map', 'marker', 'tooltip', 'popup'];\n  var PANE_RE = /-*pane/gi;\n\n  var isLeafletPane = function isLeafletPane(name) {\n    return LEAFLET_PANES.indexOf(name.replace(PANE_RE, '')) !== -1;\n  };\n\n  var paneStyles = {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n\n  var Pane =\n  /*#__PURE__*/\n  function (_Component) {\n    inherits(Pane, _Component);\n\n    function Pane() {\n      var _getPrototypeOf2;\n\n      var _this;\n\n      classCallCheck(this, Pane);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = possibleConstructorReturn(this, (_getPrototypeOf2 = getPrototypeOf$1(Pane)).call.apply(_getPrototypeOf2, [this].concat(args)));\n      defineProperty$1(assertThisInitialized(_this), \"state\", {\n        name: undefined,\n        context: undefined\n      });\n      defineProperty$1(assertThisInitialized(_this), \"setStyle\", function () {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props,\n            style = _ref.style,\n            className = _ref.className;\n\n        var pane = _this.getPane(_this.state.name);\n\n        if (pane) {\n          if (className) {\n            addClassName(pane, className);\n          }\n\n          if (style) {\n            // Without the cast, Flow throws this error:\n            //   Cannot assign style[key] to pane.style[key] because string\n            //   is incompatible with number.\n            Object.keys(style).forEach(function (key) {\n              pane.style[key] = style[key];\n            });\n          }\n        }\n      });\n      return _this;\n    }\n\n    createClass(Pane, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        this.createPane(this.props);\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        if (!this.state.name) {\n          // Do nothing if this.state.name is undefined due to errors or\n          // an invalid props.name value\n          return;\n        } // If the 'name' prop has changed the current pane is unmounted and a new\n        // pane is created.\n\n\n        if (this.props.name !== prevProps.name) {\n          this.removePane();\n          this.createPane(this.props);\n        } else {\n          // Remove the previous css class name from the pane if it has changed.\n          // setStyle() will take care of adding in the updated className\n          if (prevProps.className && this.props.className !== prevProps.className) {\n            var pane = this.getPane(this.state.name);\n\n            if (pane != null && prevProps.className != null) {\n              removeClassName(pane, prevProps.className);\n            }\n          } // Update the pane's DOM node style and class\n\n\n          this.setStyle(this.props);\n        }\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this.removePane();\n      }\n    }, {\n      key: \"createPane\",\n      value: function createPane(props) {\n        var map = props.leaflet.map;\n        var name = props.name || \"pane-\".concat(uniqueId());\n\n        if (map != null && map.createPane != null) {\n          var isDefault = isLeafletPane(name);\n          var existing = isDefault || this.getPane(name);\n\n          if (existing == null) {\n            map.createPane(name, this.getParentPane());\n          } else {\n            var message = isDefault ? \"You must use a unique name for a pane that is not a default leaflet pane (\".concat(name, \")\") : \"A pane with this name already exists. (\".concat(name, \")\");\n            warning_1(false, message);\n          }\n\n          this.setState({\n            name: name,\n            context: objectSpread({}, props.leaflet, {\n              pane: name\n            })\n          }, this.setStyle);\n        }\n      }\n    }, {\n      key: \"removePane\",\n      value: function removePane() {\n        // Remove the created pane\n        var name = this.state.name;\n\n        if (name != null) {\n          var pane = this.getPane(name);\n          if (pane != null && pane.remove) pane.remove();\n          var map = this.props.leaflet.map;\n\n          if (map != null && map._panes != null) {\n            map._panes = omit(map._panes, name);\n            map._paneRenderers = omit(map._paneRenderers, name);\n          }\n        }\n      }\n    }, {\n      key: \"getParentPane\",\n      value: function getParentPane() {\n        return this.getPane(this.props.pane || this.props.leaflet.pane);\n      }\n    }, {\n      key: \"getPane\",\n      value: function getPane(name) {\n        if (name != null && this.props.leaflet.map != null) {\n          return this.props.leaflet.map.getPane(name);\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var context = this.state.context;\n        return context ? React__default.createElement(LeafletProvider, {\n          value: context\n        }, React__default.createElement(\"div\", {\n          style: paneStyles\n        }, this.props.children)) : null;\n      }\n    }]);\n    return Pane;\n  }(React.Component);\n\n  var Pane$1 = withLeaflet(Pane);\n\n  var Polygon =\n  /*#__PURE__*/\n  function (_Path) {\n    inherits(Polygon, _Path);\n\n    function Polygon() {\n      classCallCheck(this, Polygon);\n      return possibleConstructorReturn(this, getPrototypeOf$1(Polygon).apply(this, arguments));\n    }\n\n    createClass(Polygon, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        return new leaflet.Polygon(props.positions, this.getOptions(props));\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        if (toProps.positions !== fromProps.positions) {\n          this.leafletElement.setLatLngs(toProps.positions);\n        }\n\n        this.setStyleIfChanged(fromProps, toProps);\n      }\n    }]);\n    return Polygon;\n  }(Path);\n\n  var Polygon$1 = withLeaflet(Polygon);\n\n  var Polyline =\n  /*#__PURE__*/\n  function (_Path) {\n    inherits(Polyline, _Path);\n\n    function Polyline() {\n      classCallCheck(this, Polyline);\n      return possibleConstructorReturn(this, getPrototypeOf$1(Polyline).apply(this, arguments));\n    }\n\n    createClass(Polyline, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        return new leaflet.Polyline(props.positions, this.getOptions(props));\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        if (toProps.positions !== fromProps.positions) {\n          this.leafletElement.setLatLngs(toProps.positions);\n        }\n\n        this.setStyleIfChanged(fromProps, toProps);\n      }\n    }]);\n    return Polyline;\n  }(Path);\n\n  var Polyline$1 = withLeaflet(Polyline);\n\n  var Popup =\n  /*#__PURE__*/\n  function (_DivOverlay) {\n    inherits(Popup, _DivOverlay);\n\n    function Popup() {\n      var _getPrototypeOf2;\n\n      var _this;\n\n      classCallCheck(this, Popup);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = possibleConstructorReturn(this, (_getPrototypeOf2 = getPrototypeOf$1(Popup)).call.apply(_getPrototypeOf2, [this].concat(args)));\n      defineProperty$1(assertThisInitialized(_this), \"onPopupOpen\", function (_ref) {\n        var popup = _ref.popup;\n\n        if (popup === _this.leafletElement) {\n          _this.onOpen();\n        }\n      });\n      defineProperty$1(assertThisInitialized(_this), \"onPopupClose\", function (_ref2) {\n        var popup = _ref2.popup;\n\n        if (popup === _this.leafletElement) {\n          _this.onClose();\n        }\n      });\n      defineProperty$1(assertThisInitialized(_this), \"onRender\", function () {\n        if (_this.props.autoPan !== false && _this.leafletElement.isOpen()) {\n          if (_this.leafletElement._map && _this.leafletElement._map._panAnim) {\n            _this.leafletElement._map._panAnim = undefined;\n          }\n\n          _this.leafletElement._adjustPan();\n        }\n      });\n      return _this;\n    }\n\n    createClass(Popup, [{\n      key: \"getOptions\",\n      value: function getOptions(props) {\n        return objectSpread({}, get(getPrototypeOf$1(Popup.prototype), \"getOptions\", this).call(this, props), {\n          autoPan: false\n        });\n      }\n    }, {\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        var options = this.getOptions(props);\n        options.autoPan = props.autoPan !== false;\n        return new leaflet.Popup(options, props.leaflet.popupContainer);\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        if (toProps.position !== fromProps.position) {\n          this.leafletElement.setLatLng(toProps.position);\n        }\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var position = this.props.position;\n        var _this$props$leaflet = this.props.leaflet,\n            map = _this$props$leaflet.map,\n            popupContainer = _this$props$leaflet.popupContainer;\n        var el = this.leafletElement;\n\n        if (map != null) {\n          map.on({\n            popupopen: this.onPopupOpen,\n            popupclose: this.onPopupClose\n          });\n        }\n\n        if (popupContainer) {\n          // Attach to container component\n          popupContainer.bindPopup(el);\n        } else {\n          // Attach to a Map\n          if (position) {\n            el.setLatLng(position);\n          }\n\n          el.openOn(map);\n        }\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        var map = this.props.leaflet.map;\n\n        if (map != null) {\n          map.off({\n            popupopen: this.onPopupOpen,\n            popupclose: this.onPopupClose\n          });\n          map.removeLayer(this.leafletElement);\n        }\n\n        get(getPrototypeOf$1(Popup.prototype), \"componentWillUnmount\", this).call(this);\n      }\n    }]);\n    return Popup;\n  }(DivOverlay);\n\n  defineProperty$1(Popup, \"defaultProps\", {\n    pane: 'popupPane'\n  });\n  var Popup$1 = withLeaflet(Popup);\n\n  var Rectangle =\n  /*#__PURE__*/\n  function (_Path) {\n    inherits(Rectangle, _Path);\n\n    function Rectangle() {\n      classCallCheck(this, Rectangle);\n      return possibleConstructorReturn(this, getPrototypeOf$1(Rectangle).apply(this, arguments));\n    }\n\n    createClass(Rectangle, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        return new leaflet.Rectangle(props.bounds, this.getOptions(props));\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        if (toProps.bounds !== fromProps.bounds) {\n          this.leafletElement.setBounds(toProps.bounds);\n        }\n\n        this.setStyleIfChanged(fromProps, toProps);\n      }\n    }]);\n    return Rectangle;\n  }(Path);\n\n  var Rectangle$1 = withLeaflet(Rectangle);\n\n  var ScaleControl =\n  /*#__PURE__*/\n  function (_MapControl) {\n    inherits(ScaleControl, _MapControl);\n\n    function ScaleControl() {\n      classCallCheck(this, ScaleControl);\n      return possibleConstructorReturn(this, getPrototypeOf$1(ScaleControl).apply(this, arguments));\n    }\n\n    createClass(ScaleControl, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        return new leaflet.Control.Scale(props);\n      }\n    }]);\n    return ScaleControl;\n  }(MapControl);\n\n  var ScaleControl$1 = withLeaflet(ScaleControl);\n\n  var TileLayer =\n  /*#__PURE__*/\n  function (_GridLayer) {\n    inherits(TileLayer, _GridLayer);\n\n    function TileLayer() {\n      classCallCheck(this, TileLayer);\n      return possibleConstructorReturn(this, getPrototypeOf$1(TileLayer).apply(this, arguments));\n    }\n\n    createClass(TileLayer, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        return new leaflet.TileLayer(props.url, this.getOptions(props));\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        get(getPrototypeOf$1(TileLayer.prototype), \"updateLeafletElement\", this).call(this, fromProps, toProps);\n\n        if (toProps.url !== fromProps.url) {\n          this.leafletElement.setUrl(toProps.url);\n        }\n      }\n    }]);\n    return TileLayer;\n  }(GridLayer);\n\n  var TileLayer$1 = withLeaflet(TileLayer);\n\n  var Tooltip =\n  /*#__PURE__*/\n  function (_DivOverlay) {\n    inherits(Tooltip, _DivOverlay);\n\n    function Tooltip() {\n      var _getPrototypeOf2;\n\n      var _this;\n\n      classCallCheck(this, Tooltip);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = possibleConstructorReturn(this, (_getPrototypeOf2 = getPrototypeOf$1(Tooltip)).call.apply(_getPrototypeOf2, [this].concat(args)));\n      defineProperty$1(assertThisInitialized(_this), \"onTooltipOpen\", function (_ref) {\n        var tooltip = _ref.tooltip;\n\n        if (tooltip === _this.leafletElement) {\n          _this.onOpen();\n        }\n      });\n      defineProperty$1(assertThisInitialized(_this), \"onTooltipClose\", function (_ref2) {\n        var tooltip = _ref2.tooltip;\n\n        if (tooltip === _this.leafletElement) {\n          _this.onClose();\n        }\n      });\n      return _this;\n    }\n\n    createClass(Tooltip, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        return new leaflet.Tooltip(this.getOptions(props), props.leaflet.popupContainer);\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var popupContainer = this.props.leaflet.popupContainer;\n        if (popupContainer == null) return;\n        popupContainer.on({\n          tooltipopen: this.onTooltipOpen,\n          tooltipclose: this.onTooltipClose\n        });\n        popupContainer.bindTooltip(this.leafletElement);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        var popupContainer = this.props.leaflet.popupContainer;\n        if (popupContainer == null) return;\n        popupContainer.off({\n          tooltipopen: this.onTooltipOpen,\n          tooltipclose: this.onTooltipClose\n        });\n\n        if (popupContainer._map != null) {\n          popupContainer.unbindTooltip(this.leafletElement);\n        }\n      }\n    }]);\n    return Tooltip;\n  }(DivOverlay);\n\n  defineProperty$1(Tooltip, \"defaultProps\", {\n    pane: 'tooltipPane'\n  });\n  var Tooltip$1 = withLeaflet(Tooltip);\n\n  var VideoOverlay =\n  /*#__PURE__*/\n  function (_MapLayer) {\n    inherits(VideoOverlay, _MapLayer);\n\n    function VideoOverlay() {\n      classCallCheck(this, VideoOverlay);\n      return possibleConstructorReturn(this, getPrototypeOf$1(VideoOverlay).apply(this, arguments));\n    }\n\n    createClass(VideoOverlay, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        return new leaflet.VideoOverlay(props.url, props.bounds, this.getOptions(props));\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        get(getPrototypeOf$1(VideoOverlay.prototype), \"componentDidMount\", this).call(this);\n\n        if (this.props.play === true) {\n          this.leafletElement.getElement().play();\n        }\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        if (toProps.url !== fromProps.url) {\n          this.leafletElement.setUrl(toProps.url);\n        }\n\n        if (toProps.bounds !== fromProps.bounds) {\n          this.leafletElement.setBounds(leaflet.latLngBounds(toProps.bounds));\n        }\n\n        if (toProps.opacity !== fromProps.opacity) {\n          this.leafletElement.setOpacity(toProps.opacity);\n        }\n\n        if (toProps.zIndex !== fromProps.zIndex) {\n          this.leafletElement.setZIndex(toProps.zIndex);\n        } // flowlint-next-line sketchy-null-bool:off\n\n\n        if (toProps.play === true && !fromProps.play) {\n          this.leafletElement.getElement().play(); // flowlint-next-line sketchy-null-bool:off\n        } else if (!toProps.play && fromProps.play === true) {\n          this.leafletElement.getElement().pause();\n        }\n      }\n    }]);\n    return VideoOverlay;\n  }(MapLayer);\n\n  var VideoOverlay$1 = withLeaflet(VideoOverlay);\n\n  var WMSTileLayer =\n  /*#__PURE__*/\n  function (_GridLayer) {\n    inherits(WMSTileLayer, _GridLayer);\n\n    function WMSTileLayer() {\n      classCallCheck(this, WMSTileLayer);\n      return possibleConstructorReturn(this, getPrototypeOf$1(WMSTileLayer).apply(this, arguments));\n    }\n\n    createClass(WMSTileLayer, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        var url = props.url,\n            params = objectWithoutProperties(props, [\"url\"]);\n        return new leaflet.TileLayer.WMS(url, this.getOptions(params));\n      }\n    }, {\n      key: \"updateLeafletElement\",\n      value: function updateLeafletElement(fromProps, toProps) {\n        get(getPrototypeOf$1(WMSTileLayer.prototype), \"updateLeafletElement\", this).call(this, fromProps, toProps);\n        var prevUrl = fromProps.url,\n            _po = fromProps.opacity,\n            _pz = fromProps.zIndex,\n            prevParams = objectWithoutProperties(fromProps, [\"url\", \"opacity\", \"zIndex\"]);\n        var url = toProps.url,\n            _o = toProps.opacity,\n            _z = toProps.zIndex,\n            params = objectWithoutProperties(toProps, [\"url\", \"opacity\", \"zIndex\"]);\n\n        if (url !== prevUrl) {\n          this.leafletElement.setUrl(url);\n        }\n\n        if (!fastDeepEqual(params, prevParams)) {\n          this.leafletElement.setParams(params);\n        }\n      }\n    }, {\n      key: \"getOptions\",\n      value: function getOptions(params) {\n        var superOptions = get(getPrototypeOf$1(WMSTileLayer.prototype), \"getOptions\", this).call(this, params);\n        return Object.keys(superOptions).reduce(function (options, key) {\n          if (!EVENTS_RE.test(key)) {\n            options[key] = superOptions[key];\n          }\n\n          return options;\n        }, {});\n      }\n    }]);\n    return WMSTileLayer;\n  }(GridLayer);\n\n  var WMSTileLayer$1 = withLeaflet(WMSTileLayer);\n\n  var ZoomControl =\n  /*#__PURE__*/\n  function (_MapControl) {\n    inherits(ZoomControl, _MapControl);\n\n    function ZoomControl() {\n      classCallCheck(this, ZoomControl);\n      return possibleConstructorReturn(this, getPrototypeOf$1(ZoomControl).apply(this, arguments));\n    }\n\n    createClass(ZoomControl, [{\n      key: \"createLeafletElement\",\n      value: function createLeafletElement(props) {\n        return new leaflet.Control.Zoom(props);\n      }\n    }]);\n    return ZoomControl;\n  }(MapControl);\n\n  var ZoomControl$1 = withLeaflet(ZoomControl);\n  exports.AttributionControl = AttributionControl$1;\n  exports.Circle = Circle$1;\n  exports.CircleMarker = CircleMarker$1;\n  exports.ControlledLayer = ControlledLayer;\n  exports.DivOverlay = DivOverlay;\n  exports.FeatureGroup = FeatureGroup$1;\n  exports.GeoJSON = GeoJSON$1;\n  exports.GridLayer = GridLayer;\n  exports.ImageOverlay = ImageOverlay$1;\n  exports.LayerGroup = LayerGroup$1;\n  exports.LayersControl = LayersControlExport;\n  exports.LeafletConsumer = LeafletConsumer;\n  exports.LeafletProvider = LeafletProvider;\n  exports.Map = Map;\n  exports.MapComponent = MapComponent;\n  exports.MapControl = MapControl;\n  exports.MapEvented = MapEvented;\n  exports.MapLayer = MapLayer;\n  exports.Marker = Marker$1;\n  exports.Pane = Pane$1;\n  exports.Path = Path;\n  exports.Polygon = Polygon$1;\n  exports.Polyline = Polyline$1;\n  exports.Popup = Popup$1;\n  exports.Rectangle = Rectangle$1;\n  exports.ScaleControl = ScaleControl$1;\n  exports.TileLayer = TileLayer$1;\n  exports.Tooltip = Tooltip$1;\n  exports.VideoOverlay = VideoOverlay$1;\n  exports.WMSTileLayer = WMSTileLayer$1;\n  exports.ZoomControl = ZoomControl$1;\n  exports.useLeaflet = useLeaflet;\n  exports.withLeaflet = withLeaflet;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}